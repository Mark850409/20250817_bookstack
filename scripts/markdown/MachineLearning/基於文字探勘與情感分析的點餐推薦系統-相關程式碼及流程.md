---
title: 基於文字探勘與情感分析的點餐推薦系統-相關程式碼及流程
updated: 2024-08-04 09:43:54Z
created: 2024-07-14 09:22:30Z
latitude: 25.0329694
longitude: 121.5654177
altitude: 0
tags:
  - ML
  - python
  - Order
---


以下是一個使用文本挖掘和情感分析來建立點餐推薦系統的相關程式碼和流程。為了說明，我們將使用 Python 作為主要編程語言，並使用 NLTK、TextBlob 和 Tweepy 等外部套件。

1. 安裝必要套件：
```bash
pip install nltk textblob tweepy pandas sklearn numpy matplotlib seaborn
```
2. 匯入必要的模組和函式庫。建立一個名為 `restaurant_recommender.py` 的程式，並將以下內容新增到該檔案中：
```python
import pandas as pd
from textblob import TextBlob
from nltk.corpus import stopwords
from tweepy import API, OAuthHandler
import nltk
nltk.download('vader_lexicon')  # Download the VADER lexicon if not already downloaded
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics import pairwise_distances
import numpy as np
import matplotlib.pyplot as plt
```
3. Twitter API設定：建立一個名為 `twitter_keys.py` 的檔案，並將帳戶資料新增到該檔案中。
```python
consumer_key = 'YOUR CONSUMER KEY'
consumer_secret = 'YOUR CONSUMER SECRET'
access_token = 'YOUR ACCESS TOKEN'
access_token_secret = 'YOUR ACCESS TOKEN SECRET'
```
4. 建立一個名為 `process_tweets.py` 的檔案，並寫入函式以處理推文。在該程式中，我們將使用 TextBlob 進行情感分析和預處理語言。
```python
import tweepy
from textblob import TextBlob
import re
stopwords = set(stopwords.words('english'))

def get_api():
    auth = OAuthHandler(consumer_key, consumer_secret)
    auth.set_access_token(access_token, access_token_secret)
    api = API(auth)
    return api

def preprocess(text):
    text = re.sub('[^a-zA-Z]', ' ', text)  # Remove non-alphabetic characters and spaces
    words = TextBlob(text).words.filter(lambda w: not w in stopwords)  # Filter out stopwords
    return ' '.join([word for word in words])
```
5. 建立一個名為 `load_data.py` 的檔案，將資料加載並進行初步處理。在該程式中，我們使用
# 1. 基於文字探勘與情感分析的點餐推薦系統-相關程式碼及流程


## 1.1. 簡介

讓`使用者`可以更快找到自己`心儀的`店家

## 1.2. 專案架構
```
20240802_flask_crud_vue
├─ .gitignore
├─ .gitlab-ci.yml
├─ backend
│  ├─ api_sample
│  │  ├─ call_comment_dao.py
│  │  ├─ call_drink_dao.py
│  │  ├─ call_favorite_dao.py
│  │  ├─ call_google_maps_dao.py
│  │  └─ call_user_dao.py
│  ├─ app.py
│  ├─ bert_test.py
│  ├─ Chatgpt_translate.py
│  ├─ Collaborative_filtering.py
│  ├─ config
│  │  ├─ api_info.py
│  │  ├─ setting.py
│  │  ├─ __init 10 pages of tweets (up to a maximum of 18,497 tweets)
        public_tweets = api.search(q='food OR restaurant', count=100, lang="en", result_type="recent")
        for tweet in public_tweets:
            if not re.match('^RT|http\S+|@[A-Za-z0-9]+', tweet.text):  # Filter out retweets and links
                processed_tweet = preprocess(tweet.text)
                sentiment = TextBlob(processed_tweet).sentiment.polarity
                if sentiment > 0:
                    tweets.append([processed_tweet, sentiment])
    df = pd.DataFrame(tweets, columns=['Text', 'Sentiment'])  # Create a DataFrame for the processed data
    return df
```
6. 在 `restaurant_recommender.py` 中，使用上述函式來加載和處理資料。建立一個名為 `words_matrix` 的文本矩陣以進行相似度計算。
```python
def load_and_process():
    data = load_data()  # Load and preprocess the data
    count_vectorizer = CountVectorizer(max_features=5000)  # Create a CountVectorizer instance for text transformation
    words_matrix = count_vectorizer.fit_transform(data['Text'])
    return words_matrix, data['Sentiment']
```
7. 在 `restaurant_recommender.py` 中，計算文本矩陣的相似度並建立一個名為 `similarity_matrix`。
```python
def calculate_cosine_distance(words1, words2):
    dot_product = np.dot(words1, words2)  # Dot product of two word vectors
    norm1 = np.linalg.norm(words1)  # L2-norm of the first vector
    norm2 = np.linalg.norm(words2)  # L2-norm of the second vector
    return dot_product / (norm1 * norm2) if norm1 > 0 and norm2 > 0 else 0

def calculate_similarity_matrix():
    words_matrix, _ = load_and_process()  # Load and preprocess the data if not already loaded
    n = len(words_matrix)
    similarity_matrix = pairwise_distances(words_matrix, metric='cosine')  # Calculate cosine distances between all pairs of word vectors
    return np.array([[0 if i == j else similarity_matrix[i][j]**2 for j in range(n)] for i in range(n)])
```
8. 在 `restaurant_recommender.py` 中，建立一個名為 `user_feedback` 的數據集，用來保存使用者對推薦餐廳的反饋。以後可以使用這些反饋來改善推薦系統。
```python
def user_feedback():
    feedback = pd.read_csv('user_feedback.csv') __.py
│  │  └─ __pycache__
│  │     ├─ setting.cpython-311.pyc
│  │     └─ __init__.cpython-311.pyc
│  ├─ controller
│  │  └─ __pycache__
│  │     ├─ foodpanda_service.cpython-311.pyc
│  │     ├─ location_service.cpython-311.pyc
│  │     ├─ restaurant_service.cpython-311.pyc
│  │     └─ router.cpython-311.pyc
│  ├─ controllers
│  │  ├─ comment_route.py
│  │  ├─ drink_route.py
│  │  ├─ favorite_route.py
│  │  ├─ foodpanda_route.py
│  │  ├─ googlemaps_route.py
│  │  ├─ restaurant_route.py
│  │  └─ user_route.py
│  ├─ ConvertNameToPlaceID.py
│  ├─ csv
│  │  ├─ ConvertNameToPlaceID.csv
│  │  ├─ error_log.csv
│  │  └─ google_maps_review_with_selenium.csv
│  ├─ CustomChatGLM3_translate.py
│  ├─ CustomChatGLM_translate.py
│  ├─ dao
│  │  ├─ comment_dao.py
│  │  ├─ drink_dao.py
│  │  ├─ favorite_dao.py
│  │  ├─ google_maps_dao.py
│  │  └─ user_dao.py
│  ├─ extensions
│  │  └─ extensions.py
│  ├─ extensions.py
│  ├─ google_maps_review_API_with_emotion_.py
│  ├─ google_maps_review_with_selenium.py
│  ├─ google_map_review_sample.ipynb
│  ├─ Gradio_call.py
│  ├─ Gradio_call_commend_line.py
│  ├─ image
│  │  └─ cake.png
│  ├─ LINEBOT.py
│  ├─ migrations
│  │  ├─ alembic.ini
│  │  ├─ env.py
│  │  ├─ README
│  │  ├─ script.py.mako
│  │  ├─ versions
│  │  │  ├─ 032ba1d9c789_調整欄位長度.py
│  │  │  ├─ 4bf2fa6e110f_調整欄位長度.py
│  │  │  ├─ 59af30f6e4b8_調整欄位長度.py
│  │  │  ├─ 84f7a51a1d26_調整欄位長度.py
│  │  │  ├─ e33d226b3778_移除多餘的欄位.py
│  │  │  └─ __pycache__
│  │  │     ├─ 032ba1d9c789_調整欄位長度.cpython-311.pyc
│  │  │     ├─ 4bf2fa6e110f_調整欄位長度.cpython-311.pyc
│  │  │     ├─ 59af30f6e4b8_調整欄位長度.cpython-311.pyc
│  │  │     ├─ 84f7a51a1d26_調整欄位長度.cpython-311.pyc
│  │  │     └─ e33d226b3778_移除多餘的欄位.cpython-311.pyc
│  │  └─ __pycache__
│  │     └─ env.cpython-311.pyc
│  ├─ model
│  │  ├─ Comment.py
│  │  ├─ Favorite.py
│  │  ├─ restauant_recommend_list.py
│  │  ├─ restaurant_cuisines_list.py
│  │  ├─ restaurant_type_list.py
│  │  ├─ User.py
│  │  └─ __pycache__
│  │     ├─ database.cpython-311.pyc
│  │     ├─ restauant_recommend_list.cpython-311.pyc
│  │     ├─ restaurant.cpython-311.pyc
│  │     ├─ restaurant_cuisines_list.cpython-311.pyc
│  │     ├─ restaurant_type_list.cpython-311.pyc
│  │     └─ stock.cpython-311.pyc
│  ├─ myjieba.py
│  ├─ myNLTK.py
│  ├─ mysklearn.py
│  ├─ navagation_url.py
│  ├─ requirements.txt
│  ├─ routes
│  │  └─ __pycache__
│  │     ├─ restaurant_route.cpython-311.pyc
│  │     └─ stock_route.cpython-311.pyc
│  ├─ routes_set
│  │  ├─ comment_routes.json
│  │  ├─ cuisines_list.json
│  │  ├─ drink_routes.json
│  │  ├─ favorite_routes.json
│  │  ├─ foodpanda_routes.json
│  │  ├─ googlemaps_routes.json
│  │  └─ user_routes.json
│  ├─ schemas
│  │  ├─ comment_schemas.py
│  │  ├─ drink_schemas.py
│  │  ├─ favorite_schemas.py
│  │  ├─ foodpanda_schemas.py
│  │  ├─ googlemaps_schemas.py
│  │  └─ user_schemas.py
│  ├─ SnowNLP.py
│  ├─ SwaggerAPIdoc.py
│  ├─ utils
│  │  ├─ foodpandaAPI.py
│  │  └─ sqlfunctions.py
│  └─ __pycache__
│     ├─ app.cpython-311.pyc
│     ├─ extensions.cpython-311.pyc
│     └─ setting.cpython-311.pyc
├─ CHANGELOG.md
├─ check_commit_message.sh
├─ custom-release-notes-generator.js
├─ custom.html
├─ deploy_harbor.sh
├─ docker-compose.yml
├─ dockerfiles
│  ├─ apache
│  │  └─ Dockerfile_apache
│  ├─ python
│  │  └─ Dockerfile_python
│  └─ vue
│     └─ Dockerfile_vue
├─ frontend
│  ├─ .gitignore
│  ├─ babel.config.js
│  ├─ jsconfig.json
│  ├─ package-lock.json
│  ├─ package.json
│  ├─ public
│  │  ├─ favicon.ico
│  │  └─ index.html
│  ├─ src
│  │  ├─ App.vue
│  │  ├─ components
│  │  │  ├─ footer.vue
│  │  │  ├─ get_recommand_restaurants.vue
│  │  │  ├─ google_maps.vue
│  │  │  ├─ Navbar.vue
│  │  │  ├─ recommand_restaurants.vue
│  │  │  └─ table_schema.vue
│  │  ├─ main.js
│  │  └─ router
│  │     └─ index.js
│  └─ vue.config.js
├─ Jenkinsfile
├─ math_operations.py
├─ node_modules
│  ├─ .package-lock.json
│  ├─ cors
│  │  ├─ CONTRIBUTING.md
│  │  ├─ HISTORY.md
│  │  ├─ lib
│  │  │  └─ index.js
│  │  ├─ LICENSE
│  │  ├─ package.json
│  │  └─ README.md
│  ├─ object-assign
│  │  ├─ index.js
│  │  ├─ license
│  │  ├─ package.json
│  │  └─ readme.md
│  └─ vary
│     ├─ HISTORY.md
│     ├─ index.js
│     ├─ LICENSE
│     ├─ package.json
│     └─ README.md
├─ package-lock.json
├─ package.json
├─ README.md
├─ requirements.txt
├─ send_line_notify.sh
├─ style.css
└─ test_math_operations.py
```


## 1.3. 目錄

- [1. 基於文字探勘與情感分析的點餐推薦系統-相關程式碼及流程](#1-基於文字探勘與情感分析的點餐推薦系統-相關程式碼及流程)
  - [1.1. 簡介](#11-簡介)
  - [1.2. 專案架構](#12-專案架構)
  - [1.3. 目錄](#13-目錄)
  - [1.4. 問題處理](#14-問題處理)
  - [1.5. 關鍵程式碼解說](#15-關鍵程式碼解說)
    - [1.5.1. 如何取得飲料店資料(透過FoodPandaAPI抓取)](#151-如何取得飲料店資料透過foodpandaapi抓取)
    - [1.5.2. 如何取得飲料店資料(透過GoogleMapsAPI抓取)](#152-如何取得飲料店資料透過googlemapsapi抓取)
    - [1.5.3. 模型訓練片段](#153-模型訓練片段)
  - [1.6. 實驗步驟](#16-實驗步驟)
    - [1.6.1. 對照組](#161-對照組)
    - [1.6.2. 實驗組](#162-實驗組)
    - [1.6.3. 避免overfitting的交叉測試](#163-避免overfitting的交叉測試)
  - [1.7. 推薦系統流程圖](#17-推薦系統流程圖)



## 1.4. 問題處理

> [!note] 小提示 
>1. openai版本太新似乎會有問題，遇到此問題改安裝0.28版
>2. 請在requirements.txt這邊指定版本號，不然包版預設會安裝最新版


![](https://markweb.idv.tw/uploads/202407232023390.png)

![](https://markweb.idv.tw/uploads/202407232026525.png)

<!--more-->
## 1.5. 關鍵程式碼解說

### 1.5.1. 如何取得飲料店資料(透過FoodPandaAPI抓取)

參數說明

> [!note] 小提示 
>1. COUNTRY_COUNT：各餐廳縣市抓取筆數
>2. TIMEOUT_SECONDS：定義超時時間（秒)
>3. COORDINATES：飲料店起始座標
>4. COUNTRY_RANGES：縣市經緯度範圍
>5. CITY_TRANSLATION：中英文的城市名稱對應

其中1、2為數值型態，3~5為字典型態，範例如下：

```python
# 各餐廳縣市抓取筆數
COUNTRY_COUNT = 100

# 定義超時時間（秒）
TIMEOUT_SECONDS = 90  # 假設超過120秒就視為超時

# 飲料店起始座標
COORDINATES = {
    '台北市': (25.033968, 121.564468),  # 台北101
    '新北市': (25.0143, 121.4639),  # 板橋車站
		# 以下資料請自行刪減
}

# 縣市經緯度範圍
COUNTRY_RANGES = {
    '台北市': {'lat_min': 25.0, 'lat_max': 25.2, 'lng_min': 121.5, 'lng_max': 121.7},
    '新北市': {'lat_min': 24.9, 'lat_max': 25.2
		# 以下資料請自行刪減
}
# 英文到中文的城市名稱對應
CITY_TRANSLATION = {
    'Taipei': '台北市',
    'New Taipei': '新北市'
		# 以下資料請自行刪減
}
```

程式碼說明

> [!note] 小提示 
>1. 若無資料表就建立，否則先移除後再重新建立
>2. 定義目前所在地經緯度(參數檔取得)
>3. 記錄每個縣市已抓取的筆數(存放在變數中)
>4. 設定最大抓取時間為120秒(存放在變數中)
>5. 事先建立好FoodPandaSpider(傳入初始經緯度)
>6. call get_nearby_restaurants這個function(傳入送餐方式、飲料分類ID、筆數)取得所有飲料店資料
>7. 檢查餐廳是否已存在於資料庫中
>8. 若餐廳不存在，則新增到 new_restaurants 列表中，並寫入資料庫，同時更新目前已抓取筆數
>9. 若抓取不到100筆，生成新的經緯度並重新抓取(筆數可調整)
>10. 計算總執行時間，超過120秒跳過該縣市，往下 個縣市抓取

```python
def generate_new_coordinates(county):
    """
    生成隨機經緯度，範圍限制在指定縣市內
    """
    range = COUNTRY_RANGES[county]
    latitude = random.uniform(range['lat_min'], range['lat_max'])
    longitude = random.uniform(range['lng_min'], range['lng_max'])
    return latitude, longitude

```


```python
@restaurant_route.route('/', methods=['GET'])
def InsertDrink():
    """
    將FoodPanda爬取的資料寫入飲料店管理資料庫
    """
    try:
        # 移除資料表
        db.session.execute(text("DROP TABLE IF EXISTS restaurant_type_list"))
        # 提交
        db.session.commit()
        # 重建資料表
        db.create_all()
        # 重設auto_increment
        db.session.execute(text("ALTER TABLE restaurant_type_list AUTO_INCREMENT = 1"))

        # 定義目前所在地經緯度
        coordinates = COORDINATES

        # 記錄每個縣市已抓取的筆數
        fetched_count = {county: 0 for county in coordinates}

        # 設定最大抓取時間為120秒
        max_fetch_time = timedelta(seconds=TIMEOUT_SECONDS)  # seconds

        print("===============================")

        for county, location in coordinates.items():
            start_time = datetime.now()
            print(f"開始時間: {start_time.strftime('%Y年%m月%d日 %H時%M分%S秒')}")

            while fetched_count[county] < COUNTRY_COUNT:
                current_time = datetime.now()
                print(f"目前時間: {current_time.strftime('%Y年%m月%d日 %H時%M分%S秒')}")
                latitude, longitude = location
                print(f"目前抓取的縣市: {county}, 筆數: {fetched_count[county]}")
                print(f"經緯度為: {latitude, longitude}")

                # 初始化並傳入經緯度
                foodpanda_spider = FoodPandaSpider(longitude, latitude)

                # 取得附近所有餐廳
                restaurants = foodpanda_spider.get_nearby_restaurants(
                    way='外送',
                    cuisine='181',
                    limit=COUNTRY_COUNT,
                )

                new_restaurants = []

                for restaurant in restaurants['data']:
                    try:
                        # 檢查餐廳是否已存在於資料庫中
                        db.session.query(restaurant_type_list).filter_by(name=restaurant['name']).one()
                    except NoResultFound:
                        # 若餐廳不存在，則新增到 new_restaurants 列表中
                        normalized_address, city_CN, normalized_name = normalize_address(restaurant['address'], county,
                                                                                         restaurant['name'])
                        restaurant['address'] = normalized_address
                        restaurant['city_CN'] = city_CN
                        restaurant['normalized_name'] = normalized_name
                        new_restaurants.append(restaurant)

                # 提取需要的字段並構建新字典
                for item in new_restaurants:
                    new_dinks = {
                        'name': item['name'],
                        'normalized_name': item['normalized_name'],
                        'address': item['address'],
                        'budget': item['budget'],
                        'city': item['city']['name'],
                        'city_CN': item['city_CN'],
                        'customer_phone': item['customer_phone'],
                        'description': item['description'],
                        'hero_image': item['hero_image'],
                        'hero_listing_image': item['hero_listing_image'],
                        'distance': item['distance'],
                        'is_new_until': item['is_new_until'],
                        'latitude': item['latitude'],
                        'longitude': item['longitude'],
                        'minimum_delivery_fee': item['minimum_delivery_fee'],
                        'minimum_delivery_time': item['minimum_delivery_time'],
                        'minimum_order_amount': item['minimum_order_amount'],
                        'minimum_pickup_time': item['minimum_pickup_time'],
                        'primary_cuisine_id': item['primary_cuisine_id'],
                        'rating': item['rating'],
                        'redirection_url': item['redirection_url'],
                        'review_number': item['review_number'],
                        'tag': item['tag']
                    }
                    # 寫入資料庫
                    DrinkDAO.create_drink(new_dinks)

                # 寫入資料庫並更新已抓取的筆數
                fetched_count[county] += len(new_restaurants)

                # 若抓取不到100筆，生成新的經緯度並重新抓取
                if fetched_count[county] < COUNTRY_COUNT:
                    latitude, longitude = generate_new_coordinates(county)
                    location = (latitude, longitude)
                    print(f"新的經緯度為: {location}")

                # 計算總執行時間
                total_time = datetime.now() - start_time
                print(f"目前總執行時間: {total_time}秒")
                print(f"時間限制為: {max_fetch_time}秒")
                print(f"還有幾秒: {max_fetch_time - total_time}結束，即將跳過{county} 的抓取")
                print("===============================")
                # 單獨判斷該市或縣是否繼續抓取
                if datetime.now() - start_time > max_fetch_time:
                    print(f"超過時間，跳過 {county} 的抓取")
                    break
    # 捕捉SQL錯誤訊息
    except SQLAlchemyError as e:
        db.session.rollback()
        error_msg = str(e)
        sql_statement = getattr(e, 'statement', None)
        return jsonify(ErrorResponse(error='Database error occurred.', sql_error_message=error_msg,
                                     sql_statement=sql_statement).dict()), 500
    # 捕捉其他錯誤訊息
    except Exception as e:
        return jsonify(ErrorResponse(message=str(e)).dict()), 500

```



### 1.5.2. 如何取得飲料店資料(透過GoogleMapsAPI抓取)


參數說明

> [!note] 小提示 
>  1. MAX_WORKERS：最大線呈數
> 2. COMMENT_COUNT：每次抓取的評論筆數
> 3. 1、2皆為數值型態，範例如下：

```python
# 最大線呈數
MAX_WORKERS = 10

# 每次抓取的評論筆數
COMMENT_COUNT = 10
```


程式碼說明

> [!note] 小提示 
> 1. 若無資料表就建立，否則先移除後再重新建立
> 2. 使用 ThreadPoolExecutor 進行平行處理(主要是處理效能問題)

```python
# 取得googlemaps評論
def google_maps_review_processing():
    # 移除CSV避免重複建立
    if os.path.exists('csv/error_log.csv'):
        os.remove('csv/error_log.csv')

    # 移除資料表避免重複建立
    sql_query = "DROP TABLE IF EXISTS google_maps_review_with_selenium;"
    drop_query(db.session, sql_query)

    # 移除CSV避免重複建立
    if os.path.exists('csv/google_maps_review_with_selenium.csv'):
        os.remove('csv/google_maps_review_with_selenium.csv')

    # 使用 SQL 語法查詢所有用戶
    sql_query = "SELECT id,normalized_name FROM restaurant_type_list"
    # 確認上述程式跑完了，才執行以下程式
    get_restaurants_name = execute_query(db.session, sql_query)

    # 收集店家名稱和ID
    restaurant_data = [(row.normalized_name, row.id) for row in get_restaurants_name]

    # 使用 ThreadPoolExecutor 進行平行處理
    with ThreadPoolExecutor(max_workers=max_workers) as executor:  # 設置最大線呈數量
        futures = []
        for name, rest_id in restaurant_data:
            futures.append(executor.submit(get_place_review_with_selenium, name, rest_id, comment_count))
        for future in as_completed(futures):
            try:
                result = future.result()
                # print(result)
            except Exception as e:
                print(f"Error occurred: {e}")
```


> [!note] 小提示 
>1. 使用python selenium在背景執行，並將視窗最大化
>2. 取得初始URL(googlemaps)
>3. 定位到搜尋框並傳入文字
>4. 定位到查詢按鈕
>5. 定位到每家餐廳的標題
>6. 定位到評論頁籤並點擊
>7. 取得店家評論數量
>8. 如果評論數小於要求的最小評論數，抓取所有現有的評論
>9. 透過BeautifulSoup取得google評論相關內容
>10. 使用CHATGPT中翻英並做情緒分析
>11. 將BeautifulSoup取得的相關內容和情緒分析一同寫入資料表

```python
def get_place_review_with_selenium(my_restaurant_name, rest_id, comment_count):
    options = webdriver.ChromeOptions()
    # 背景執行
    options.add_argument('--headless')

    # 視窗最大化
    options.add_argument("start-maximized")

    # 休息1秒
    time.sleep(1)

    browser = webdriver.Chrome(options=options)

    # 基本url
    url = 'https://www.google.com.tw/maps/@25.0328862,121.5491486,17z?entry=ttu'

    # 取得url
    browser.get(url)

    # 錯誤訊息清單
    error_list = []
    id = 0

    # 記錄開始時間
    start_time = datetime.now()
    print(f"開始時間: {start_time.strftime('%Y年%m月%d日 %H時%M分%S秒')}")
    print("===============================")

    try:
        # ----------------------------------------------------------------------------------------
        # python selenium 爬蟲程式碼
        # ----------------------------------------------------------------------------------------

        # 清空搜尋框文字
        WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//*[@id='searchboxinput']"))).clear()

        # 定位到搜尋框並傳入文字
        WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//*[@id='searchboxinput']"))).send_keys(my_restaurant_name)

        # 休息1秒
        time.sleep(1)

        # 定位到查詢按鈕
        WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.XPATH, "//*[@id='searchbox-searchbutton']"))).click()

        # 休息1秒
        time.sleep(1)

        # 取得html網頁元素
        soup = BeautifulSoup(browser.page_source, 'html.parser')

        # 定位到每家餐廳的標題
        place_name_element = soup.find('h1', {'class': 'DUwDvf lfPIob'})

        if not place_name_element:
            print(f"找不到店家: {my_restaurant_name}")
            error_list.append((my_restaurant_name, "找不到店家"))
            # 检查文件是否存在或为空
            write_header = not os.path.isfile('csv/error_log.csv') or os.stat('csv/error_log.csv').st_size == 0
            # 将出错店家信息写入CSV文件
            if error_list:
                error_df = pd.DataFrame(error_list, columns=['店家名稱', '錯誤訊息'])
                if write_header:
                    error_df.to_csv('csv/error_log.csv', index=False, encoding='utf-8-sig', mode='w', header=True)
                else:
                    error_df.to_csv('csv/error_log.csv', index=False, encoding='utf-8-sig', mode='a', header=False)
            return

        # 休息1秒
        time.sleep(1)

        # 定位到評論頁籤並點擊
        WebDriverWait(browser, 10).until(
            EC.element_to_be_clickable((By.XPATH,
                                        "//*[@id='QA0Szd']/div/div/div[1]/div[2]/div/div[1]/div/div/div[3]/div/div/button[2]/div[2]"))).click()

        # 取得店家評論數量
        review_count_element = WebDriverWait(browser, 10).until(
            EC.presence_of_element_located((By.XPATH,
                                            "//*[@id='QA0Szd']/div/div/div[1]/div[2]/div/div[1]/div/div/div[2]/div[2]/div/div[2]/div[3]")))
        review_count_text = review_count_element.text.strip()
        review_count = int(re.search(r'\d+', review_count_text).group()) if review_count_text else 0

        # 如果評論數小於要求的最小評論數，抓取所有現有的評論
        if review_count < comment_count:
            print("===============================")
            print(
                f"店家 {my_restaurant_name} 的評論數 {review_count} 小於您要求的最小評論數，筆數為{comment_count}，將抓取所有現有的評論")
            required_reviews = review_count
        else:
            print("===============================")
            print(f"抓取所有評論筆數為: {comment_count}")
            required_reviews = comment_count

        # 評論數的起始值
        tmp = browser.find_elements(By.XPATH, "//div[@class='jftiEf fontBodyMedium ']")

        # ----------------------------------------------------------------------------------------
        # 取得評論
        # ----------------------------------------------------------------------------------------

        # 評論總數
        while len(tmp) < int(required_reviews):
            browser.execute_script('''
                const body = document.querySelector(`
                    div.m6QErb.DxyBCb.kA9KIf.dS8AEf`);
    
                body.scrollTo(0, body.scrollHeight);
            ''')

            time.sleep(0.5)

            tmp = browser.find_elements(By.XPATH, "//div[@class='jftiEf fontBodyMedium ']")

        # ----------------------------------------------------------------------------------------
        # 抓取資料及欄位定義
        # ----------------------------------------------------------------------------------------
        # 取得html網頁元素
        soup = BeautifulSoup(browser.page_source, 'html.parser')

        # 取得使用者
        reviewer = soup.find_all('div', {'class': 'd4r55'})
        # 取得星級
        stars = soup.find_all('span', {'class': 'kvMYJc'})
        # 取得評論
        contents = soup.find_all('span', {'class': 'wiI7pd'})
        # 取得時間
        review_dates = soup.find_all('span', {'class': 'rsqaWe'})

        name = [r_name.text for r_name in reviewer]
        scores = [re.search(r'\d+', rating['aria-label']).group() for rating in stars]
        review_text = [review.text for review in contents]
        dates = [date.text for date in review_dates]
        place_name = place_name_element.text

        # 如果沒有評論就跳過，並記錄到CSV
        if not name or not scores or not review_text:
            error_list.append((my_restaurant_name, "未能找到有效的評論數據"))
            print("===============================")
            print(f"未能找到有效的評論數據，跳過店家: {my_restaurant_name}")
            # 将出错店家信息写入CSV文件
            if error_list:
                error_df = pd.DataFrame(error_list)
                error_df.to_csv('csv/error_log.csv', index=False, encoding='utf-8-sig', mode='a+', header=False)
            return
            # continue

        # 相關資料加入陣列
        all_data = list(zip([place_name] * len(name), name, scores, review_text, dates))

        # 轉換為dataframe
        df = pd.DataFrame(all_data, columns=['restaurant_name', 'user', 'rating', 'text', 'time'])

        # 取得place_id
        place_id = get_place_data(api_key, my_restaurant_name)

        print("===============================")
        print(f"抓取所有google place id: {place_id}")

        comments = df['text']

        print("===============================")
        print(f"抓取評論內容為: {review_text}")

        df['id'] = rest_id

        print("===============================")
        print(f"抓取評論ID為: {rest_id}")

        df['place_id'] = place_id

        # ----------------------------------------------------------------------------------------
        # CHATGPT 中翻英
        # ----------------------------------------------------------------------------------------
        english_texts = translate_to_english(comments)
        df['english_texts'] = english_texts
        # ----------------------------------------------------------------------------------------
        # 情感分析程式碼
        # ----------------------------------------------------------------------------------------
        # 計算情感分數
        # result = analyze_sentiment_batch(comments)
        # result = analyze_sentiment_with_bert(comments)
        result = analyze_sentiment_with_NLTK(english_texts)

        # 將欄位取出放到dataframe
        analysis_df = pd.DataFrame(result,
                                   columns=['positive_prob', 'negative_prob', 'composite_score', 'confidence',
                                            'sentiment'])
        # 將欄位取到小數第 位
        df['positive_prob'] = analysis_df['positive_prob'].round(2)
        df['negative_prob'] = analysis_df['negative_prob'].round(2)
        df['composite_score'] = analysis_df['composite_score'].round(2)
        df['confidence'] = analysis_df['confidence'].round(2)
        df['sentiment'] = analysis_df['sentiment']

        # ----------------------------------------------------------------------------------------
        # jieba結合TF-IDF程式碼
        # ----------------------------------------------------------------------------------------

        # jieba結合TF-IDF進行斷詞
        tokenized_comments = tokenize_and_clean_comments(comments, stopwords)

        # 使用 TF-IDF 進行詞頻計算
        vectorizer = TfidfVectorizer()
        tfidf_matrix = vectorizer.fit_transform(tokenized_comments)
        feature_names = vectorizer.get_feature_names_out()
        tfidf_scores = tfidf_matrix.toarray()

        # 計算每個評論的總評分
        keywords_scores = calculate_score(tfidf_scores, feature_names, KEYWORDS_WEIGHTS, 1)
        df['keywords_scores'] = keywords_scores
        df['keywords_scores'] = df['keywords_scores'].round(2)

        # ----------------------------------------------------------------------------------------
        # 寫入資料庫及EXCEL程式碼
        # ----------------------------------------------------------------------------------------

        # 指定欄位順序
        df = df[
            ['id', 'place_id', 'restaurant_name', 'user', 'rating', 'text', 'english_texts', 'time', 'positive_prob',
             'negative_prob', 'composite_score', 'confidence', 'keywords_scores', 'sentiment']]

        # 指定欄位型態
        dtype = {
            'id': Integer(),
            'rating': Float()
        }

        # 將結果寫入新的 CSV
        df.to_csv('csv/google_maps_review_with_selenium.csv', encoding='utf-8-sig', mode='a+',
                  header=True)
        # 將結果寫入新的 SQL 資料表
        df.to_sql('google_maps_review_with_selenium', engine, if_exists='append', dtype=dtype)
    except Exception as e:
        print(f"處理店家 {my_restaurant_name} 時出錯: {str(e)}")
        # 将出错店家信息写入CSV文件
        if error_list:
            error_list.append((my_restaurant_name, f"處理店家 {my_restaurant_name} 時出錯: {str(e)}"))
            error_df = pd.DataFrame(error_list)
            error_df.to_csv('csv/error_log.csv', index=False, encoding='utf-8-sig', mode='a+', header=False)
    finally:
        browser.quit()

    # 記錄結束時間
    end_time = datetime.now()
    print(f"結束時間: {end_time.strftime('%Y年%m月%d日 %H時%M分%S秒')}")

    # 計算總執行時間
    total_time = end_time - start_time
    print(f"總執行時間: {total_time}秒")
```


```python

# 計算情感分析(NLTK)
def analyze_sentiment_with_NLTK(texts):
    results = []
    # 遍歷並分析每個文本
    for idx, text in enumerate(texts, 1):
        # 分析文本情感
        scores = sid.polarity_scores(text)

        # 提取情感分析結果並取小數點後兩位
        pos_score = round(scores['pos'], 2)
        neg_score = round(scores['neg'], 2)
        neu_score = round(scores['neu'], 2)
        compound_score = round(scores['compound'], 2)

        # 判斷情感類別
        if compound_score >= 0.05:
            sentiment = '正向情感'
        elif compound_score <= -0.05:
            sentiment = '負向情感'
        else:
            sentiment = '中性情感'

        # 將結果添加到列表
        results.append([pos_score, neg_score, neu_score, compound_score, sentiment])

    return results

```


```python
# 定義翻譯函數
def translate_to_english(texts):
    translations = []

    for text in texts:
        messages = [
            {"role": "system",
             "content": "You are a helpful AI assistant that translates text from Chinese to English."},
            {"role": "user", "content": f"Translate the following text from Chinese to English:\n\n{text}"}
        ]

        # 設定 API 請求參數
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=messages,
            max_tokens=1024,
            n=1,
            stop=None,
            temperature=0.5,
        )

        # 解析回應
        translation = response.choices[0].message["content"].strip()
        translations.append(translation)

    return translations
```


### 1.5.3. 模型訓練片段

資料取得

> [!note] 小提示 
>1. ratings_df：評分資料集  
>2. restaurants_df：餐廳資料集  
>3. merged_df：合併後的資料集  
>4. count_df：計算資料筆數  
>5. unique_users：將使用者取出然後重新編號

```python
# ===========================================================
# 從資料庫取得資料集
# ===========================================================

# 建立連線
connect_ibfo = setting.SQLALCHEMY_DATABASE_URI
engine = create_engine(connect_ibfo)

# 取得評分資料集
ratings_df = pd.read_sql('''select GMRW.id,GMRW.place_id,GMRW.restaurant_name,GMRW.rating,GMRW.composite_score,GMRW.user,RTL.city,RTL.city_CN,RTL.distance,RTL.review_number
from google_maps_review_with_selenium GMRW
JOIN restaurant_type_list  RTL ON  RTL.id=GMRW.id
where confidence>=0.7
''', con=engine)

# 建立user對應ID的表格，從1開始編號
unique_users = ratings_df['user'].unique()
user_to_id = {user: idx + 1 for idx, user in enumerate(unique_users)}

# 使用 user_to_id 替换 'user' 列中的值
ratings_df['user_id'] = ratings_df['user'].map(user_to_id)

# 取得餐廳資料集
restaurants_df = pd.read_sql(
    "SELECT * FROM ConvertNameToPlaceID WHERE navigation_url<>'No navigation found' and place_id is not null",
    con=engine)

# 取得筆數資料集
count_data = pd.read_sql(
    "SELECT count(*) as count from restaurant_type_list",
    con=engine)

count_df = pd.DataFrame(count_data)

# 建立評分資料集
ratings_data = {
    'user_id': ratings_df['user_id'],
    'restaurant_id': ratings_df['place_id'],
    'restaurant_name': ratings_df['restaurant_name'],
    'rating': ratings_df['rating'],
    'sentiment_score': ratings_df['composite_score'],
    'city': ratings_df['city_CN'],
    'distance': ratings_df['distance'],
    'review_number': ratings_df['review_number']
}
ratings_df = pd.DataFrame(ratings_data)

# 建立餐廳資料集
restaurants_data = {
    'restaurant_id': restaurants_df['place_id'],
    'latitude': restaurants_df['latitude'],
    'longitude': restaurants_df['longitude'],
    'name': restaurants_df['place_names'],
    'redirection_url': restaurants_df['redirection_url'],
    'navigation_url': restaurants_df['navigation_url'],
}
restaurants_df = pd.DataFrame(restaurants_data)

# 建立餐廳名稱對應ID的表格
name_to_id = {row['name']: row['restaurant_id'] for _, row in restaurants_df.iterrows()}

# 建立餐廳ID對應餐廳名稱的表格
id_to_name = {row['restaurant_id']: row['name'] for _, row in restaurants_df.iterrows()}

# 建立foodpanda餐廳URL對應餐廳ID的表格
redirection_url_to_id = {row['restaurant_id']: row['redirection_url'] for _, row in restaurants_df.iterrows()}

# 建立googlemap導航對應餐廳ID的表格
navigation_url_to_id = {row['restaurant_id']: row['navigation_url'] for _, row in restaurants_df.iterrows()}

# 建立city對應餐廳ID的表格
city_url_to_id = {row['restaurant_id']: row['city'] for _, row in ratings_df.iterrows()}

# 資料集合併
merged_df = pd.merge(ratings_df, restaurants_df, on='restaurant_id')
```

情感分析+餐廳評分(定義權重)

> [!note] 小提示 
>1. base_rating_weight：餐廳評分權重
>2. base_overall_sentiment_weight：情感評分權重
>3. train_data：訓練資料集
>4. test_data：測試資料集
>5. train_user_restaurant_matrix：建立用户-餐廳矩陣

```python
# 定義初始權重
base_rating_weight = 0.7
base_overall_sentiment_weight = 0.3

# 正規化餐廳評分、情感分數
scaler = MinMaxScaler()
ratings_df['normalized_rating'] = scaler.fit_transform(ratings_df[['rating']])
ratings_df['normalized_sentiment_score'] = scaler.fit_transform(ratings_df[['sentiment_score']])

# 動態調整權重，使用指數函數或其他非線性函數
ratings_df['dynamic_rating_weight'] = np.exp(ratings_df['normalized_rating']) * base_rating_weight
ratings_df['dynamic_sentiment_weight'] = np.exp(
    ratings_df['normalized_sentiment_score']) * base_overall_sentiment_weight

# 確保權重之和為1
total_weight = ratings_df['dynamic_rating_weight'] + ratings_df['dynamic_sentiment_weight']
ratings_df['dynamic_rating_weight'] /= total_weight
ratings_df['dynamic_sentiment_weight'] /= total_weight

# 打印或存儲動態權重
print(ratings_df[['dynamic_rating_weight', 'dynamic_sentiment_weight']])

# 計算未正規化的綜合評分
ratings_df['unscaled_combined_score'] = (
        ratings_df['normalized_rating'] * ratings_df['dynamic_rating_weight'] +
        ratings_df['sentiment_score'] * ratings_df['dynamic_sentiment_weight']
)

# 正規化綜合評分，確保在0到1之間
scaler_combined = MinMaxScaler()
ratings_df['weighted_combined_score'] = scaler_combined.fit_transform(ratings_df[['unscaled_combined_score']])

# 將資料集拆分為訓練集與測試集
train_data, test_data = train_test_split(ratings_df, test_size=0.2, random_state=42)

# 建立用户-餐廳矩陣，使用综合評分
train_user_restaurant_matrix = ratings_df.pivot_table(index='user_id', columns='restaurant_id',
                                                      values='weighted_combined_score').fillna(0)
```


推薦方式(協同過濾)

> [!note] 小提示 
> 1. train_user_restaurant_matrix：特徵矩陣資料集
> 2. n_neighbors：相似用戶數
> 3. distances：餘弦相似度的距離
> 4. indices：餘弦相似度的索引

```python

# 推薦餐廳主程式(協同過濾)
def recommend_restaurants(user_id, num_recommendations):
    if user_id not in train_user_restaurant_matrix.index:
        print(f"{user_id}這筆資料在矩陣內找不到，要不換一筆試試?")
        return []
    else:
        user_index = train_user_restaurant_matrix.index.get_loc(user_id)

        db_count = int(count_df['count'].iloc[0])

        print(f"餐廳資料集的筆數是: {db_count}\n")

        # 設定較大的 n_neighbors 值以擴大潛在推薦範圍
        n_neighbors = min(num_recommendations * random.randint(1, 5), len(train_user_restaurant_matrix))

        # 取出距離計算餘弦相似度
        distances, indices = knn.kneighbors(train_user_restaurant_matrix.iloc[user_index, :].values.reshape(1, -1),
                                            n_neighbors=n_neighbors)

        # 取出相似度最高的前5個使用者的索引和距離
        top_5_indices = indices.flatten()[1:6]  # 排除自己，取出前5個相似用戶的索引
        top_5_distances = distances.flatten()[1:6]  # 取出前5個相似用戶的距離

        print(f"與{user_id}相似度最高的前5個使用者及其距離是：\n")

        for idx, (user_idx, distance) in enumerate(zip(top_5_indices, top_5_distances), 1):
            similar_user_id = train_user_restaurant_matrix.index[user_idx]
            print(f"{idx}. 使用者ID: {similar_user_id}, 相似度距離: {distance:.2f}")

            # 取出相似用戶的評分資料
            similar_user_ratings = train_data[train_data['user_id'] == similar_user_id]
            printed_restaurant_ids = set()  # 用於跟踪已打印的餐廳ID

            for _, row in similar_user_ratings.iterrows():
                restaurant_id = row['restaurant_id']
                if restaurant_id not in printed_restaurant_ids:
                    print(
                        f"======================================\n餐廳ID: {row['restaurant_id']}\n評分: {row['rating']}\n餐廳名稱: {row['restaurant_name']}\n所在城市: {row['city']}\n======================================")
                    printed_restaurant_ids.add(restaurant_id)

        # 隨機選擇部分鄰居的索引
        random_neighbors = random.sample(range(1, len(distances.flatten())),
                                         min(num_recommendations * 1, len(distances.flatten()) - 1))

        # 用於存放餐廳
        recommended_restaurants = []

        # 用於追蹤已推薦的餐廳ID
        recommended_ids = set()

        # 用於存放城市數量
        city_count = {}

        for i in random_neighbors:
            similar_user_id = train_user_restaurant_matrix.index[indices.flatten()[i]]
            similar_user_ratings = train_data[train_data['user_id'] == similar_user_id]

            for _, row in similar_user_ratings.iterrows():
                restaurant_id = row['restaurant_id']
                if restaurant_id not in recommended_ids:
                    # 取得經緯度
                    restaurant_location = restaurants_df[restaurants_df['restaurant_id'] == restaurant_id]
                    # 若經緯度為空就跳過
                    if restaurant_location.empty:
                        continue
                    # 取得相關資訊
                    restaurant_name = id_to_name.get(restaurant_id)
                    redirection_urls = redirection_url_to_id.get(restaurant_id)
                    navigation_urls = navigation_url_to_id.get(restaurant_id)
                    city = city_url_to_id.get(restaurant_id)
                    # 確保每個城市推薦的餐廳不超過指定數量
                    if city_count.get(city, 0) <= 1:
                        recommended_restaurants.append((restaurant_name, restaurant_location['latitude'].values[0],
                                                        restaurant_location['longitude'].values[0], redirection_urls,
                                                        navigation_urls, city))
                        recommended_ids.add(restaurant_id)
                        city_count[city] = city_count.get(city, 0) + 1
                    # 如果推薦餐廳已滿，跳出內層循環
                    if len(recommended_restaurants) >= num_recommendations:
                        break
            # 如果推薦餐廳已滿，跳出外層循環
            if len(recommended_restaurants) >= num_recommendations:
                break
        # 增加隨機性，從推薦列表中隨機選擇指定數量的餐廳
        if len(recommended_restaurants) > num_recommendations:
            recommended_restaurants = random.sample(recommended_restaurants, num_recommendations)
        else:
            recommended_restaurants = recommended_restaurants[:num_recommendations]
    # 返回最近的num_recommendations家餐廳的名稱和經緯度
    return recommended_restaurants
```

推薦方式(內容推薦)

```python
# 推薦餐廳主程式(內容推薦)
def content_based_recommendations(user_id, num_recommendations):
    # 計算餐廳之間內容相似性
    content_similarities = cosine_similarity(train_user_restaurant_matrix)

    # 隨機選擇10間使用者可能感興趣的餐廳
    num_random_restaurants = 10
    random_restaurant_indices = random.sample(range(len(restaurants_df)), num_random_restaurants)

    # 用於存放城市數量
    city_count = {}

    # 根據隨機選擇的餐廳，找到相似度高的餐廳
    similar_restaurants = []
    for idx in random_restaurant_indices:
        restaurant_similarities = content_similarities[idx]
        top_indices = restaurant_similarities.argsort()[::-1][:num_recommendations]
        for top_idx in top_indices:
            # 超過索引值範圍就跳過
            if top_idx >= len(restaurants_df):
                continue
            restaurant_id = restaurants_df.iloc[top_idx]['restaurant_id']
            # 如果餐廳ID不在原先的推薦列表且餐廳列表的數量小於指定推薦數量，才放到列表進行推薦，否則就不推薦
            if restaurant_id not in similar_restaurants and len(similar_restaurants) < num_recommendations:
                similar_restaurants.append(restaurant_id)
        # 如果餐廳列表大於推薦數量，就跳過
        if len(similar_restaurants) >= num_recommendations:
            break

    # 根據餐廳ID和相關訊息放入推薦列表
    recommended_restaurants = []

    for restaurant_id in similar_restaurants:
        restaurant_info = restaurants_df[restaurants_df['restaurant_id'] == restaurant_id]
        rating_info = ratings_df[ratings_df['restaurant_id'] == restaurant_id]
        if not restaurant_info.empty and not rating_info.empty:
            city = rating_info['city'].values[0]
            # 確保每個城市推薦的餐廳不超過指定數量
            if city_count.get(city, 0) < 1:
                recommended_restaurants.append((
                    restaurant_info['name'].values[0],
                    restaurant_info['latitude'].values[0],
                    restaurant_info['longitude'].values[0],
                    restaurant_info['redirection_url'].values[0],
                    restaurant_info['navigation_url'].values[0],
                    city
                ))
                city_count[city] = city_count.get(city, 0) + 1

    # 如果推薦餐廳不足 num_recommendations，隨機補足，並確保城市不重複
    while len(recommended_restaurants) < num_recommendations:
        random_idx = np.random.randint(len(restaurants_df))
        restaurant_id = restaurants_df.iloc[random_idx]['restaurant_id']
        restaurant_info = restaurants_df[restaurants_df['restaurant_id'] == restaurant_id]
        rating_info = ratings_df[ratings_df['restaurant_id'] == restaurant_id]
        # 確保restaurant_info和rating_info不為空
        if not restaurant_info.empty and not rating_info.empty:
            city = rating_info['city'].values[0]
            # 確保每個城市推薦的餐廳不超過指定數量
            if city_count.get(city, 0) < 1:
                recommended_restaurants.append((
                    restaurant_info['name'].values[0],
                    restaurant_info['latitude'].values[0],
                    restaurant_info['longitude'].values[0],
                    restaurant_info['redirection_url'].values[0],
                    restaurant_info['navigation_url'].values[0],
                    city
                ))
                city_count[city] = city_count.get(city, 0) + 1
    # 回傳指定推薦的餐廳數量
    return recommended_restaurants[:num_recommendations]

```

推薦方式(混合推薦)

```python
# 推薦餐廳主程式(混合推薦)
def hybrid_recommendations(user_id, num_recommendations):
    if user_id not in train_user_restaurant_matrix.index:
        print(f"{user_id}這筆資料在矩陣內找不到，要不換一筆試試?")
        return []
    else:
        # 用於存放城市數量
        city_count = {}
        # 取得協同過濾推薦餐廳
        cf_recommendations = recommend_restaurants(user_id, num_recommendations)
        # 取得內容推薦餐廳
        content_recommendations = content_based_recommendations(user_id, num_recommendations)
        # 將兩個推薦結果合併
        all_recommendations = cf_recommendations + content_recommendations
        # 存放唯一的推薦結果
        unique_recommendations = []
        seen = set()
        for rec in all_recommendations:
            # 沒有推薦過的餐廳才進行推薦
            if rec not in seen:
                # 取得所有城市
                city = rec[5]
                # 確保每個城市推薦的餐廳不超過指定數量
                if city_count.get(city, 0) < 1:
                    unique_recommendations.append(rec)
                    city_count[city] = city_count.get(city, 0) + 1
                seen.add(rec)

        if len(unique_recommendations) > num_recommendations:
            unique_recommendations = random.sample(unique_recommendations, num_recommendations)

    return unique_recommendations[:num_recommendations]
```

呼叫主程式進行推薦

```python
# ===========================================================
# 推薦主程式進入點
# ===========================================================

# 使用隨機亂數抽取餐廳資料集裡任5個數字當user_id
user_ids = random.sample(range(1, int(count_df['count'].iloc[0])), 1)
num_recommendations = 5
print(f'''
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================
''')
for user_id in user_ids:
    recommendations = hybrid_recommendations(user_id, num_recommendations)
    print(f"推薦給使用者【{user_id}】的餐廳如下：\n")
    for name, lat, lon, redirection_url, navigation_url, city in recommendations:
        print(f"餐廳名稱：{name}\n經度：{lon}\n緯度：{lat}\n所在城市：{city}")
        print("=============================")
# 評估模型準確度
results = evaluate_model()
if results:
    rmse, mae, cm, accuracy, precision, recall, f1, class_report = results
    print(f"RMSE:{rmse:.2f}")
    print(f"MAE:{mae:.2f}")
    print("=============================")
    print(f"準確率:{accuracy:.2f}")
    print(f"精確率:{precision:.2f}")
    print(f"召回率:{recall:.2f}")
    print(f"F1評分:{f1:.2f}")
    print("=============================")
    print("報表:\n", class_report)
```

## 1.6. 實驗步驟

### 1.6.1. 對照組

模型訓練結果-對照組(以情感分析&餐廳評分計算權重)

```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1580

與187相似度最高的前5個使用者及其距離是：

1. 使用者ID: 2104, 相似度距離: 0.13
======================================
餐廳ID: ChIJGxGWqqVPXTQRy9F5nKMjC8o
評分: 5.0
餐廳名稱: 清心福全基隆南榮店-珍珠奶茶手搖飲料專賣店-仁愛熱門飲料|必喝飲料|外帶飲品|平價飲品|珍珠奶茶推薦|飲品店推薦
所在城市: 宜蘭市
======================================
2. 使用者ID: 2106, 相似度距離: 0.13
======================================
餐廳ID: ChIJGxGWqqVPXTQRy9F5nKMjC8o
評分: 5.0
餐廳名稱: 清心福全基隆南榮店-珍珠奶茶手搖飲料專賣店-仁愛熱門飲料|必喝飲料|外帶飲品|平價飲品|珍珠奶茶推薦|飲品店推薦
所在城市: 宜蘭市
======================================
3. 使用者ID: 2105, 相似度距離: 0.13
======================================
餐廳ID: ChIJGxGWqqVPXTQRy9F5nKMjC8o
評分: 5.0
餐廳名稱: 清心福全基隆南榮店-珍珠奶茶手搖飲料專賣店-仁愛熱門飲料|必喝飲料|外帶飲品|平價飲品|珍珠奶茶推薦|飲品店推薦
所在城市: 宜蘭市
======================================
4. 使用者ID: 2108, 相似度距離: 0.13
5. 使用者ID: 2109, 相似度距離: 0.13
======================================
餐廳ID: ChIJGxGWqqVPXTQRy9F5nKMjC8o
評分: 5.0
餐廳名稱: 清心福全基隆南榮店-珍珠奶茶手搖飲料專賣店-仁愛熱門飲料|必喝飲料|外帶飲品|平價飲品|珍珠奶茶推薦|飲品店推薦
所在城市: 宜蘭市
======================================
推薦給使用者【187】的餐廳如下：

餐廳名稱：清心福全 (基隆南榮店)
經度：121.743
緯度：25.121
所在城市：宜蘭市
=============================
餐廳名稱：老賴茶棧 (中壢忠貞店)
經度：121.257
緯度：24.9346
所在城市：桃園市
=============================
餐廳名稱：可不可熟成紅茶 (新竹城隍廟店)
經度：120.965
緯度：24.8041
所在城市：新竹市
=============================
餐廳名稱：鴻糖茶坊
經度：121.554
緯度：25.0304
所在城市：台北市
=============================
餐廳名稱：7號方舟
經度：120.816
緯度：24.5524
所在城市：苗栗市
=============================
RMSE:0.26
MAE:0.18
=============================
準確率:0.78
精確率:0.85
召回率:0.89
F1評分:0.87
=============================
報表:
               precision    recall  f1-score   support

           0       0.28      0.20      0.23       167
           1       0.85      0.89      0.87       828

    accuracy                           0.78       995
   macro avg       0.56      0.55      0.55       995
weighted avg       0.75      0.78      0.76       995

```

### 1.6.2. 實驗組

模型訓練結果-實驗組(單純以餐廳評分)

```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1713

與306相似度最高的前5個使用者及其距離是：

1. 使用者ID: 304, 相似度距離: 0.00
======================================
餐廳ID: ChIJIWdgmMSrQjQR6ipMXo_3LRg
評分: 5.0
餐廳名稱: 享想 忠孝Sogo店
所在城市: 台北市
======================================
2. 使用者ID: 306, 相似度距離: 0.00
======================================
餐廳ID: ChIJIWdgmMSrQjQR6ipMXo_3LRg
評分: 5.0
餐廳名稱: 享想 忠孝Sogo店
所在城市: 台北市
======================================
3. 使用者ID: 307, 相似度距離: 0.00
======================================
餐廳ID: ChIJIWdgmMSrQjQR6ipMXo_3LRg
評分: 5.0
餐廳名稱: 享想 忠孝Sogo店
所在城市: 台北市
======================================
4. 使用者ID: 308, 相似度距離: 0.00
======================================
餐廳ID: ChIJIWdgmMSrQjQR6ipMXo_3LRg
評分: 5.0
餐廳名稱: 享想 忠孝Sogo店
所在城市: 台北市
======================================
推薦給使用者【306】的餐廳如下：

餐廳名稱：享想（忠孝SOGO店）
經度：121.546
緯度：25.0437
所在城市：台北市
=============================
餐廳名稱：龜記茗品 (板橋南雅店)
經度：121.456
緯度：25.0058
所在城市：新北市
=============================
餐廳名稱：Like17 in 礁溪 (宜蘭礁溪店)
經度：121.77
緯度：24.8231
所在城市：宜蘭市
=============================
餐廳名稱：COMEBUY (基隆暖暖店)
經度：121.736
緯度：25.1002
所在城市：基隆市
=============================
餐廳名稱：先喝道 (新竹南大店)
經度：120.965
緯度：24.7945
所在城市：新竹市
=============================
```


 模型訓練結果-實驗組(單純以情感分析)

```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1580

與384相似度最高的前5個使用者及其距離是：

1. 使用者ID: 375, 相似度距離: 0.00
======================================
餐廳ID: ChIJC0XAbuerQjQR1mchXwvkJFs
評分: 5.0
餐廳名稱: MoMore Lemon 慕慕檸暴打檸檬茶
所在城市: 台北市
======================================
2. 使用者ID: 377, 相似度距離: 0.00
======================================
餐廳ID: ChIJC0XAbuerQjQR1mchXwvkJFs
評分: 5.0
餐廳名稱: MoMore Lemon 慕慕檸暴打檸檬茶
所在城市: 台北市
======================================
3. 使用者ID: 378, 相似度距離: 0.00
======================================
餐廳ID: ChIJC0XAbuerQjQR1mchXwvkJFs
評分: 5.0
餐廳名稱: MoMore Lemon 慕慕檸暴打檸檬茶
所在城市: 台北市
======================================
4. 使用者ID: 381, 相似度距離: 0.00
======================================
餐廳ID: ChIJC0XAbuerQjQR1mchXwvkJFs
評分: 5.0
餐廳名稱: MoMore Lemon 慕慕檸暴打檸檬茶
所在城市: 台北市
======================================
5. 使用者ID: 380, 相似度距離: 0.00
======================================
餐廳ID: ChIJC0XAbuerQjQR1mchXwvkJFs
評分: 5.0
餐廳名稱: MoMore Lemon 慕慕檸暴打檸檬茶
所在城市: 台北市
======================================
推薦給使用者【384】的餐廳如下：

餐廳名稱：慕慕檸暴打檸檬茶
經度：121.543
緯度：25.0332
所在城市：台北市
=============================
餐廳名稱：CoCo都可 (桃園大同店)
經度：121.313
緯度：24.9897
所在城市：桃園市
=============================
餐廳名稱：泰讚了 (府中南雅店)
經度：121.456
緯度：25.0056
所在城市：新北市
=============================
餐廳名稱：CoCo都可 (基隆中船店)
經度：121.751
緯度：25.1373
所在城市：基隆市
=============================
餐廳名稱：宜蘭古意奶茶
經度：121.753
緯度：24.758
所在城市：宜蘭市
=============================
RMSE:4.34
MAE:4.13
=============================
準確率:0.06
精確率:1.00
召回率:0.06
F1評分:0.11
=============================
報表:
               precision    recall  f1-score   support

           0       0.00      0.00      0.00         0
           1       1.00      0.06      0.11       103

    accuracy                           0.06       103
   macro avg       0.50      0.03      0.06       103
weighted avg       1.00      0.06      0.11       103

```


 模型訓練結果-實驗組(以情感分析*餐廳評分無權重)
```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1580

與1257相似度最高的前5個使用者及其距離是：

1. 使用者ID: 1248, 相似度距離: 0.00
======================================
餐廳ID: ChIJi6jS0fepQjQR2iVDACTu5g4
評分: 5.0
餐廳名稱: 一手私藏世界紅茶 板橋四維店
所在城市: 新北市
======================================
2. 使用者ID: 1249, 相似度距離: 0.00
======================================
餐廳ID: ChIJi6jS0fepQjQR2iVDACTu5g4
評分: 5.0
餐廳名稱: 一手私藏世界紅茶 板橋四維店
所在城市: 新北市
======================================
3. 使用者ID: 1251, 相似度距離: 0.00
======================================
餐廳ID: ChIJi6jS0fepQjQR2iVDACTu5g4
評分: 5.0
餐廳名稱: 一手私藏世界紅茶 板橋四維店
所在城市: 新北市
======================================
4. 使用者ID: 1253, 相似度距離: 0.00
======================================
餐廳ID: ChIJi6jS0fepQjQR2iVDACTu5g4
評分: 5.0
餐廳名稱: 一手私藏世界紅茶 板橋四維店
所在城市: 新北市
======================================
5. 使用者ID: 1254, 相似度距離: 0.00
======================================
餐廳ID: ChIJi6jS0fepQjQR2iVDACTu5g4
評分: 5.0
餐廳名稱: 一手私藏世界紅茶 板橋四維店
所在城市: 新北市
======================================
推薦給使用者【1257】的餐廳如下：

餐廳名稱：一手私藏世界紅茶 (板橋四維店)
經度：121.463
緯度：25.0293
所在城市：新北市
=============================
餐廳名稱：COMEBUY (基隆廟口店)
經度：121.744
緯度：25.1283
所在城市：基隆市
=============================
餐廳名稱：冰饌紅茶粉圓 (台北虎林店)
經度：121.577
緯度：25.0395
所在城市：台北市
=============================
餐廳名稱：山峰茗茶
經度：121.748
緯度：24.7448
所在城市：宜蘭市
=============================
餐廳名稱：查理國王 (桃園廣福店)
經度：121.297
緯度：24.9592
所在城市：桃園市
=============================
RMSE:0.74
MAE:0.72
=============================
準確率:0.08
精確率:1.00
召回率:0.06
F1評分:0.11
=============================
報表:
               precision    recall  f1-score   support

           0       0.02      1.00      0.04         2
           1       1.00      0.06      0.11       101

    accuracy                           0.08       103
   macro avg       0.51      0.53      0.08       103
weighted avg       0.98      0.08      0.11       103
```


### 1.6.3. 避免overfitting的交叉測試

先將評分資料集隨機排序抓取5000筆實驗

```python
# 取得評分資料集
ratings_df = pd.read_sql('''select GMRW.id,GMRW.place_id,GMRW.restaurant_name,GMRW.rating,GMRW.composite_score,GMRW.user,RTL.city,RTL.city_CN,RTL.distance,RTL.review_number  
from google_maps_review_with_selenium GMRW  
JOIN restaurant_type_list  RTL ON  RTL.id=GMRW.id  
where confidence>=0.7 or confidence<= -0.7  
ORDER BY RAND()  
LIMIT 5000;  
''', con=engine)
```

第一次實驗結果
```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1580

與701相似度最高的前5個使用者及其距離是：

1. 使用者ID: 4377, 相似度距離: 0.00
======================================
餐廳ID: ChIJH37g5c_kZzQRQcckkbep7Ao
評分: 5.0
餐廳名稱: Mr. Wish宜蘭中山店
所在城市: 宜蘭市
======================================
2. 使用者ID: 2599, 相似度距離: 0.00
3. 使用者ID: 701, 相似度距離: 0.00
======================================
餐廳ID: ChIJH37g5c_kZzQRQcckkbep7Ao
評分: 5.0
餐廳名稱: Mr. Wish宜蘭中山店
所在城市: 宜蘭市
======================================
4. 使用者ID: 673, 相似度距離: 0.00
======================================
餐廳ID: ChIJH37g5c_kZzQRQcckkbep7Ao
評分: 1.0
餐廳名稱: Mr. Wish宜蘭中山店
所在城市: 宜蘭市
======================================
5. 使用者ID: 569, 相似度距離: 0.00
======================================
餐廳ID: ChIJH37g5c_kZzQRQcckkbep7Ao
評分: 5.0
餐廳名稱: Mr. Wish宜蘭中山店
所在城市: 宜蘭市
======================================
推薦給使用者【701】的餐廳如下：

餐廳名稱：Mr.Wish 鮮果茶玩家 (宜蘭中山店)
經度：121.753
緯度：24.7603
所在城市：宜蘭市
=============================
餐廳名稱：85度C (基隆新豐店)
經度：121.787
緯度：25.1358
所在城市：基隆市
=============================
餐廳名稱：舞茶道 (台北八里店)
經度：121.399
緯度：25.1471
所在城市：新北市
=============================
餐廳名稱：果滴滴 Futi Fudi (大安延吉店)
經度：121.556
緯度：25.0354
所在城市：台北市
=============================
餐廳名稱：萬波島嶼紅茶 (龍崗體育園區店)
經度：121.249
緯度：24.9434
所在城市：桃園市
=============================
RMSE:0.25
MAE:0.17
=============================
準確率:0.79
精確率:0.86
召回率:0.90
F1評分:0.88
=============================
報表:
               precision    recall  f1-score   support

           0       0.28      0.20      0.23       160
           1       0.86      0.90      0.88       836

    accuracy                           0.79       996
   macro avg       0.57      0.55      0.56       996
weighted avg       0.76      0.79      0.77       996
```


第二次實驗結果
```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1580

與1185相似度最高的前5個使用者及其距離是：

1. 使用者ID: 3738, 相似度距離: 0.00
2. 使用者ID: 2927, 相似度距離: 0.00
======================================
餐廳ID: ChIJJ91SKgADaDQR9KwgF1hncg0
評分: 5.0
餐廳名稱: 波漾水果珍珠專賣店（板橋仁愛店）
所在城市: 新北市
======================================
3. 使用者ID: 2809, 相似度距離: 0.00
======================================
餐廳ID: ChIJJ91SKgADaDQR9KwgF1hncg0
評分: 5.0
餐廳名稱: 波漾水果珍珠專賣店（板橋仁愛店）
所在城市: 新北市
======================================
4. 使用者ID: 2810, 相似度距離: 0.00
======================================
餐廳ID: ChIJJ91SKgADaDQR9KwgF1hncg0
評分: 5.0
餐廳名稱: 波漾水果珍珠專賣店（板橋仁愛店）
所在城市: 新北市
======================================
5. 使用者ID: 2131, 相似度距離: 0.00
推薦給使用者【1185】的餐廳如下：

餐廳名稱：一兩十錢青草鋪
經度：121.555
緯度：25.0309
所在城市：台北市
=============================
餐廳名稱：春芳號 (宜蘭復興店)
經度：121.754
緯度：24.7498
所在城市：宜蘭市
=============================
餐廳名稱：喫茶小舖 (頭份信義店)
經度：120.907
緯度：24.6869
所在城市：苗栗市
=============================
餐廳名稱：可不可熟成紅茶 (新竹站前店)
經度：120.971
緯度：24.8027
所在城市：桃園市
=============================
餐廳名稱：波漾水果珍珠專賣店 (板橋仁愛店)
經度：121.459
緯度：24.9995
所在城市：新北市
=============================
RMSE:0.26
MAE:0.17
=============================
準確率:0.80
精確率:0.87
召回率:0.90
F1評分:0.88
=============================
報表:
               precision    recall  f1-score   support

           0       0.32      0.27      0.29       154
           1       0.87      0.90      0.88       841

    accuracy                           0.80       995
   macro avg       0.59      0.58      0.59       995
weighted avg       0.78      0.80      0.79       995
```


第三次實驗結果

```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1580

與883相似度最高的前5個使用者及其距離是：

1. 使用者ID: 4444, 相似度距離: 0.00
2. 使用者ID: 3791, 相似度距離: 0.00
======================================
餐廳ID: ChIJI5Gjkn4faDQR1fmczFJuxHo
評分: 5.0
餐廳名稱: 軍茶-桃園永安店-桃園特色飲料店|打卡飲料店|人氣飲料店|優質高山茶|買一送一手搖飲料|在地推薦飲料
所在城市: 桃園市
======================================
3. 使用者ID: 3331, 相似度距離: 0.00
======================================
餐廳ID: ChIJI5Gjkn4faDQR1fmczFJuxHo
評分: 5.0
餐廳名稱: 軍茶-桃園永安店-桃園特色飲料店|打卡飲料店|人氣飲料店|優質高山茶|買一送一手搖飲料|在地推薦飲料
所在城市: 桃園市
======================================
4. 使用者ID: 3320, 相似度距離: 0.00
5. 使用者ID: 3110, 相似度距離: 0.00
======================================
餐廳ID: ChIJI5Gjkn4faDQR1fmczFJuxHo
評分: 5.0
餐廳名稱: 軍茶-桃園永安店-桃園特色飲料店|打卡飲料店|人氣飲料店|優質高山茶|買一送一手搖飲料|在地推薦飲料
所在城市: 桃園市
======================================
推薦給使用者【883】的餐廳如下：

餐廳名稱：軍茶 (桃園永安店)
經度：121.305
緯度：24.9979
所在城市：桃園市
=============================
餐廳名稱：17 Drink Cafe' (板橋亞東店)
經度：121.45
緯度：24.995
所在城市：新北市
=============================
餐廳名稱：鶴茶樓 鶴頂紅茶商店 (大安通化店)
經度：121.554
緯度：25.0312
所在城市：台北市
=============================
餐廳名稱：清心福全 (頭份文化店)
經度：120.901
緯度：24.7013
所在城市：新竹市
=============================
餐廳名稱：水雲朵DrinkStore (基隆武崙店)
經度：121.71
緯度：25.1402
所在城市：基隆市
=============================
RMSE:0.27
MAE:0.19
=============================
準確率:0.77
精確率:0.86
召回率:0.86
F1評分:0.86
=============================
報表:
               precision    recall  f1-score   support

           0       0.28      0.28      0.28       163
           1       0.86      0.86      0.86       832

    accuracy                           0.77       995
   macro avg       0.57      0.57      0.57       995
weighted avg       0.76      0.77      0.76       995
```

第四次實驗結果

```
# ===========================================================
# 歡迎使用點餐推薦系統
# ===========================================================

餐廳資料集的筆數是: 1580

與824相似度最高的前5個使用者及其距離是：

1. 使用者ID: 1903, 相似度距離: 0.00
======================================
餐廳ID: ChIJt6KS9Z81aDQR0tXJYe0MR_A
評分: 5.0
餐廳名稱: 吳家紅茶冰-西大店
所在城市: 桃園市
======================================
2. 使用者ID: 1504, 相似度距離: 0.00
======================================
餐廳ID: ChIJt6KS9Z81aDQR0tXJYe0MR_A
評分: 5.0
餐廳名稱: 吳家紅茶冰-西大店
所在城市: 桃園市
======================================
3. 使用者ID: 1408, 相似度距離: 0.00
======================================
餐廳ID: ChIJt6KS9Z81aDQR0tXJYe0MR_A
評分: 3.0
餐廳名稱: 吳家紅茶冰-西大店
所在城市: 桃園市
======================================
4. 使用者ID: 824, 相似度距離: 0.00
======================================
餐廳ID: ChIJt6KS9Z81aDQR0tXJYe0MR_A
評分: 5.0
餐廳名稱: 吳家紅茶冰-西大店
所在城市: 桃園市
======================================
5. 使用者ID: 770, 相似度距離: 0.00
======================================
餐廳ID: ChIJt6KS9Z81aDQR0tXJYe0MR_A
評分: 5.0
餐廳名稱: 吳家紅茶冰-西大店
所在城市: 桃園市
======================================
推薦給使用者【824】的餐廳如下：

餐廳名稱：吳家紅茶冰 (新竹西大店)
經度：120.966
緯度：24.8014
所在城市：桃園市
=============================
餐廳名稱：北投紅茶 (大安店)
經度：121.546
緯度：25.0436
所在城市：台北市
=============================
餐廳名稱：CoCo都可 (新竹明湖店)
經度：120.967
緯度：24.7889
所在城市：新竹市
=============================
餐廳名稱：天仁茗茶 (基隆店)
經度：121.743
緯度：25.1283
所在城市：基隆市
=============================
餐廳名稱：佐奶252
經度：121.463
緯度：25.0009
所在城市：新北市
=============================
RMSE:0.27
MAE:0.19
=============================
準確率:0.76
精確率:0.84
召回率:0.88
F1評分:0.86
=============================
報表:
               precision    recall  f1-score   support

           0       0.28      0.23      0.25       173
           1       0.84      0.88      0.86       821

    accuracy                           0.76       994
   macro avg       0.56      0.55      0.56       994
weighted avg       0.75      0.76      0.75       994
```

## 1.7. 推薦系統流程圖

![](https://markweb.idv.tw/uploads/202409042057454.png)