---
title: 基於文字探勘與情感分析的點餐推薦系統-上版流程
updated: 2024-08-09 13:27:11Z
created: 2024-07-27 10:14:16Z
latitude: 25.0329694
longitude: 121.5654177
altitude: 0
tags:
  - ML
  - Order
  - Pipeline
  - Jenkins
  - python
---

# 1. 基於文字探勘與情感分析的點餐推薦系統-上版流程

## 1.1. 簡介

使用`自動化部署`，加速開發上版流程

## 1.2. 目錄

- [1. 基於文字探勘與情感分析的點餐推薦系統-上版流程](#1-基於文字探勘與情感分析的點餐推薦系統-上版流程)
  - [1.1. 簡介](#11-簡介)
  - [1.2. 目錄](#12-目錄)
  - [1.3. 操作步驟(Gitlab)](#13-操作步驟gitlab)
    - [1.3.1. 部署流程前關鍵腳本](#131-部署流程前關鍵腳本)
      - [1.3.1.1. 撰寫check\_commit\_message.sh](#1311-撰寫check_commit_messagesh)
    - [1.3.2. 部署流程關鍵腳本](#132-部署流程關鍵腳本)
      - [1.3.2.1. 撰寫.gitlab-ci.yml](#1321-撰寫gitlab-ciyml)
      - [1.3.2.2. 撰寫custom-release-notes-generator.js](#1322-撰寫custom-release-notes-generatorjs)
      - [1.3.2.3. 撰寫package.json](#1323-撰寫packagejson)
  - [1.4. 操作步驟(Jenkins)](#14-操作步驟jenkins)
    - [1.4.1. 部署流程前關鍵腳本](#141-部署流程前關鍵腳本)
      - [1.4.1.1. 撰寫python、vue、apache的dockerfle](#1411-撰寫pythonvueapache的dockerfle)
      - [1.4.1.2. 撰寫docker-compose.yml](#1412-撰寫docker-composeyml)
    - [1.4.2. 部署流程關鍵腳本](#142-部署流程關鍵腳本)
      - [1.4.2.1. 撰寫docker自動化部署腳本](#1421-撰寫docker自動化部署腳本)
      - [1.4.2.2. 撰寫Jenkins pipeline](#1422-撰寫jenkins-pipeline)
      - [1.4.2.3. 撰寫單元測試所需腳本](#1423-撰寫單元測試所需腳本)
    - [1.4.3. 部署後流程所需腳本](#143-部署後流程所需腳本)
      - [1.4.3.1. 撰寫LINE NOTIFY部署後通知腳本](#1431-撰寫line-notify部署後通知腳本)
      - [1.4.3.2. 撰寫郵件通知模板](#1432-撰寫郵件通知模板)
  - [1.5. 問題處理](#15-問題處理)
  - [1.6. 完成畫面](#16-完成畫面)

## 1.3. 操作步驟(Gitlab)

### 1.3.1. 部署流程前關鍵腳本

#### 1.3.1.1. 撰寫check_commit_message.sh

```bash
#!/bin/bash
#+-------------------------------------腳本說明--------------------------------------------+
# 提交訊息檢查腳本
# 使用方式: ./check_commit_message.sh
#
# (C) 2023 - markhsu - licensed under markweb License v1.
#
#+----------------------------------------------------------------------------------------+
# 取得提交訊息
COMMIT_MESSAGE=$1

# 定義HEADER正規表達式
PATTERN="^(feat|fix|docs|style|refactor|test|chore): .*"

# 定義FOOTER正規表達式
FOOTER_PATTERN="^redmine: #[0-9]+$"

echo "我的提交訊息是:$COMMIT_MESSAGE"

# 检查HEADER提交訊息是否符合格式
if [[ ! "$COMMIT_MESSAGE" =~ $PATTERN ]]; then
    echo "
❌ 請檢查您的提交訊息是否正確喔~
🎸feat: 新增/修改功能 (Feature)
🐛fix: 修正 Bug (bug fix)
⚡️ perf: 提高效能的程式碼修正
💡refactor: 重構 or 優化，不屬於 bug 也不屬於新增功能等
🏹release: 新增正式釋出的 release commit 訊息
💄style: 修改程式碼格式或風格，不影響原有運作
💍test: 增加測試功能
    "
    exit 1
fi


# 檢查提交訊息中body的内容是否為空
# BODY_CONTENT=$(grep '^body:' <<< "$COMMIT_MESSAGE" | sed 's/^body://')
# if [[ -z "${BODY_CONTENT// }" ]]; then
#     echo "❌ 請檢查您的提交訊息是否正確喔~
#     ❌ body不能為空
#     📓 格式: body後面冒號加上半形空白，後面開始輸入訊息
#     "
#     exit 1
# fi

# 检查FOOTER提交訊息是否符合格式
# if [[ ! "$COMMIT_MESSAGE" =~ $FOOTER_PATTERN ]]; then
#     echo "
# ❌ 請檢查您的footer提交訊息是否正確喔~
# 📓 格式: REDMINE: #123
#     "
#     exit 1
# fi

# 消息正確就會到這邊
echo "✅ 恭喜，您的提交訊息是正確的."
exit 0

```

<!--more-->
### 1.3.2. 部署流程關鍵腳本

#### 1.3.2.1. 撰寫.gitlab-ci.yml

```yaml
cache:
  paths:
    - node_modules/

stages:
  - check_commit_message
  - semantic-release

# 31 檢核提交訊息
check_commit_message:
  stage: check_commit_message
  script:
    - sh check_commit_message.sh "$CI_COMMIT_MESSAGE"
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
      changes:
        - '**/*'  # 檢查所有文件的提交消息

# 32 Change log 版號變更
semantic-release:
  stage: semantic-release
  image: node:latest
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  script:
    - echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" >> .npmrc
    - npm install semver
    - npm install -g --save-dev conventional-changelog-conventionalcommits semantic-release @semantic-release/changelog @semantic-release/gitlab @semantic-release/git @semantic-release/npm @semantic-release/release-notes-generator @semantic-release/gitlab-config
    - export GL_TOKEN=${GL_TOKEN}
    - GL_TOKEN=${GL_TOKEN} npx semantic-release
  tags:
    - docker
```

#### 1.3.2.2. 撰寫custom-release-notes-generator.js

```javascript
/*+-------------------------------------腳本說明--------------------------------------------+
* 語意化版本紀錄產生腳本
* 使用方式:
* (C) 2023 - markhsu - licensed under markweb License v1.
+----------------------------------------------------------------------------------------+*/
// 導入需要的模組
const { execSync } = require('child_process');
const semver = require('semver');

// 傳入相關的參數，並自定義語意化腳本HEADER
module.exports = (pluginConfig, context) => {
  const { env } = context;
  const { CI_COMMIT_SHA: hash, CI_COMMIT_MESSAGE: rawMessage, CI_COMMIT_TAG: tag, CI_PROJECT_URL: projectUrl,CI_COMMIT_AUTHOR_NAME: AUTHOR_NAME,CI_COMMITTER_NAME: COMMITTER_NAME} = env;
  const typeEmojiMap = {
    feat: { emoji: '✨', text: '新增功能' },
    fix: { emoji: '🐞', text: '調整BUG' },
    docs: { emoji: '📃', text: '更新文件' },
    style: { emoji: '🌈', text: '調整樣式' },
    refactor: { emoji: '♻️', text: '程式碼重購' },
    perf: { emoji: '🚀', text: '效能調整' },
    test: { emoji: '🔬', text: '單元測試' },
    build: { emoji: '🐎', text: '部署' },
    ci: { emoji: '🔧', text: 'CI' },
    chore: { emoji: '🔨', text: '雜項' },
    revert: { emoji: '⏪', text: '退版' },
    wip: { emoji: '🚧', text: '進行中' }
  };

  // 使用Git命令取得作者
  const authorName = execSync('git log --format="%an" -n 2 | tail -n 1').toString().trim();

  // 使用Git命令取得標籤
  let latestTag;
  try {
    latestTag = execSync('git describe --tags --abbrev=0').toString().trim();
  } catch (error) {
    // 取得標籤失敗使用初始化版本
    latestTag = 'v1.0.0';
  }

  console.log("latestTag:"+latestTag)


  // 取得提交訊息的REDMINE單號
  const redmineIssue = rawMessage.match(/(REDMINE: #\d+)/i)?.[0];
  console.log("redmineIssue:"+redmineIssue)

  let redmineIssueNumber =''
  let redmineIssueLink =''

  if (redmineIssue!=""&&redmineIssue!=null) {
    console.log("REDMINE單號判斷!!!")

    // 取得提交訊息的REDMINE單號不包含前綴(REDMINE:)
    redmineIssueNumber = redmineIssue ? redmineIssue.split(':')[1].trim().toLowerCase():""
    console.log("redmineIssueNumber:"+redmineIssueNumber)

    // 產生Redmine連結(不包含#)
    redmineIssueLink = redmineIssueNumber ? `https://markweb.idv.tw:18443/issues/${redmineIssueNumber.replace('#', '')}`:"";
    console.log("redmineIssueLink:"+redmineIssueLink)
  }

  // 根據提交類型定義跳版規則(fix、feat、style...)
  const releaseType = (rawMessage.split(':')[0].trim().toLowerCase());
  console.log("releaseType:"+releaseType)

  // 如果是feat就跳minor版號，其他的就跳patch
  const incrementType = releaseType=="feat" ? 'minor' : 'patch';
  console.log("incrementType:"+incrementType)


   // 根據不同提交類型加上不同的表情符號
  const message = rawMessage.split(':')[1].trim();
  console.log("原始訊息:"+message)
  console.log("原始切割訊息:"+rawMessage.split(':'))
  console.log("提交類型:"+rawMessage.split(':')[0])
  console.log("訊息內容:"+rawMessage.split(':')[1])

  // 判断提交消息是否包含 "BREAKING CHANGE" 關鍵字的正規表達式
  const breakingChangeRegex = /BREAKING\s*CHANGE(S)?/i;

  console.log("提交消息有breakingChange嗎? "+breakingChangeRegex.test(message))

  // 检查提交消息是否包含 "BREAKING CHANGE" 關鍵字，有就跳大版號，否則就照預設規則
  const hasBreakingChange = breakingChangeRegex.test(message)

  // 如果是第 次生成標籤，版號設為V1.0.0，且跳板規則是小版號
  //const nextVersion = latestTag === 'v1.0.0' ? '1.0.0' : semver.inc(latestTag,incrementType);
  let nextVersion=''
  if(latestTag === 'v1.0.0'){
    nextVersion='1.0.0'
    console.log("預設初始版號:"+nextVersion)
  }
  else if(hasBreakingChange){
    nextVersion=semver.inc(latestTag,'major')
    console.log("breakingChange大版號:"+nextVersion)
  }
  else{
    nextVersion=semver.inc(latestTag,incrementType)
    console.log("其他版號:"+nextVersion)
  }

  // 生成版本號碼連結
  const tagLink = `[v${nextVersion}](${projectUrl}/-/compare/${latestTag}...v${nextVersion})`;

  // 使用正则表达式匹配 "BREAKING CHANGE" 冒号后面的文本内容
  const breakingChangeRegexContent = /BREAKING\s+CHANGE:\s*(.*)/i;
  const match = breakingChangeRegexContent.exec(rawMessage);
  let breakingChangeDescription=''
  // 如果找到匹配项，则打印冒号右边的文本内容
  if (match && match.length > 1) {
    breakingChangeDescription = match[1].trim();
    console.log("Breaking Change Description:", breakingChangeDescription);
  } else {
    console.log("No Breaking Change description found.");
  }

  // output的訊息不要包含redmine(無論大小寫)
  new_message = message.replace(/(BREAKING\s*CHANGE(S)?)|(REDMINE)/gi, '');
  console.log("新的訊息是:"+new_message)

  //取得提交訊息類型
  const messageType = rawMessage.split(':')[0].trim();
  //串聯成{ emoji, text }格式
  const { emoji, text } = typeEmojiMap[messageType] || { emoji: '💡', text: '此次為重大變更版本 - '+"("+breakingChangeDescription+")" };

  // 日期格式為 YYYY-MM-DD
  const currentDate = new Date().toISOString().split('T')[0];
  // 加入版權聲明
  const copyright = `
  > 本文件採自動化生成，如需要更多信息，請查看semantic-release。
  `;
  // 获取倒数第 次提交的时间戳
  const commitTimestamp = execSync('git log -2 --pretty=format:%ct | tail -1').toString().trim();

  // 获取提交时间
  const commitDate = new Date(commitTimestamp * 1000); // 将时间戳转换为日期对象
  commitDate.setHours(commitDate.getHours() + 8); // 调整时区为 GMT+8
  const formattedCommitDate = commitDate.toISOString().replace('T', ' ').replace(/\.\d+Z$/, '');

  // 輸出格式為-訊息(SHA)
  let output = `- ${new_message} (${hash.slice(0, 7)})`;

  let final_output =``;

  // 判斷看需不需要加上REDMINE
  if (redmineIssue!=""&&redmineIssue!=null) {
    console.log("REDMINE單訊息判斷!!!")
    final_output=`## ${tagLink} (${currentDate})\n\n ### ${emoji} ${text} ([${redmineIssueNumber}](${redmineIssueLink})) \n\n${output}－by ${authorName} - [${formattedCommitDate}]`
  }
  else{
    console.log("沒有REDMINE單訊息判斷!!!")
    final_output=`## ${tagLink} (${currentDate})\n\n ### ${emoji} ${text} \n\n${output}－${authorName} - [${formattedCommitDate}]`
  }
  // 串接訊息後回傳
  return final_output
};
```

#### 1.3.2.3. 撰寫package.json

```json
{
    "name": "myflaskCrudVue",
    "version": "1.3.2",
    "author": "markhsu",
    "private": true,
    "workspaces": [
        "packages/*"
    ],
    "scripts": {
        "semantic-release": "semantic-release"
    },
    "repository": {
        "type": "git",
        "url": "git+https://markweb.idv.tw:10443/dockercomposeteam/flaskcrudvue_localhost.git"
    },
    "release": {
        "extends": "@semantic-release/gitlab-config",
        "plugins": [
            [
                "@semantic-release/commit-analyzer",
                {
                    "path": "./custom-release-notes-generator.js"
                }
            ],
            [
                "@semantic-release/release-notes-generator",
                {
                    "preset": "conventionalcommits",
                    "parserOpts": {
                        "noteKeywords": [
                            "BREAKING CHANGE",
                            "BREAKING CHANGES",
                            "BREAKING"
                        ]
                    }
                }
            ],
            "@semantic-release/gitlab"
        ],
        "prepare": [
            "@semantic-release/changelog",
            "@semantic-release/npm",
            {
                "path": "@semantic-release/git",
                "assets": [
                    "package.json",
                    "package-lock.json",
                    "CHANGELOG.md"
                ],
                "message": "${nextRelease.type === 'major' ? '🛠️chore(release):這次是重大版更!!!' : '🐞feat/fix(release):這只是小版更!!!'}\n\n v${nextRelease.version} 新的專案版本已釋出!!! [skip ci]"
            }
        ],
        "generateNotes": {
            "path": "./custom-release-notes-generator.js"
        }
    },
    "dependencies": {
        "cors": "^2.8.5",
        "semver": "^7.6.3"
    }
}

```

## 1.4. 操作步驟(Jenkins)

### 1.4.1. 部署流程前關鍵腳本

#### 1.4.1.1. 撰寫python、vue、apache的dockerfle

```docker 
FROM php:7.4-apache
RUN apt-get update && apt-get upgrade -y && apt install vim -y
RUN a2enmod rewrite && a2enmod ssl && a2enmod socache_shmcb && a2enmod headers
```

```docker
# 使用 Python 基礎映像
FROM python:3.8.11-slim

# 設置工作目錄
WORKDIR /usr/src/app

# 複製後端源代碼到工作目錄
COPY backend/requirements.txt ./
COPY backend/ ./backend/

# 安裝後端依賴
RUN pip install -r requirements.txt

# 暴露 Flask 應用程序的端口
EXPOSE 5000

# 啟動 Flask 應用程序
CMD ["python", "app.py"]

```

```docker
# base image
FROM node:20.12.2-alpine

# set working directory
WORKDIR /app

# add `/app/node_modules/.bin` to $PATH
ENV PATH /app/node_modules/.bin:$PATH

# g++ compiler for fibers and sass
RUN apk add --no-cache python3 make g++

# install app dependencies
COPY frontend /app
COPY frontend/package.json /app/package.json
COPY frontend/package-lock.json /app/package-lock.json
RUN npm install
RUN npm install @vue/cli -g

CMD npm run serve

```

#### 1.4.1.2. 撰寫docker-compose.yml

```yaml
version: "3.3"
services:
  frontend:
    image: ${IMAGE_NAME_VUE}
    container_name: vuewithflask_frontend
    volumes:
      - '/media/markhsu/Data/DockerProtainer/vueWithFlask/frontend:/app'
      - '/app/node_modules'
    ports:
      - 9005:8080
    restart: always
    environment:
      - CHOKIDAR_USEPOLLING=true
      - NODE_ENV=development
      - BACKEND_SERVICE_URL=https://markweb.idv.tw:28443
      - VUE_GATEWAY_URL=https://markweb.idv.tw:30443
    networks:
      - api_bridge

  backend:
    image: ${IMAGE_NAME_PYTHON}
    container_name: vuewithflask_backend
    volumes:
      - /media/markhsu/Data/DockerProtainer/vueWithFlask/backend:/usr/src/app
    ports:
      - 9006:5000
    environment:
      - FLASK_ENV=development
      - APP_SETTINGS=project.config.DevelopmentConfig
      - SECRET_KEY=my_precious
    networks:
      - api_bridge
    restart: always

  db:
    image: mysql:5.7
    container_name: vuewithflask_db
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    ports:
      - '9007:3306'
    volumes:
      - /media/markhsu/Data/DockerProtainer/vueWithFlask/db_data:/var/lib/mysql
    restart: always
    networks:
      - api_bridge

  # phpmyadmin
  phpmyadmin:
    depends_on:
      - db
    image: phpmyadmin
    container_name: vuewithflask_phpmyadmin
    restart: always
    ports:
      - '9009:80'
    environment:
      PMA_HOST: db
      PMA_ABSOLUTE_URI: https://markweb.idv.tw:27443
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    networks:
      - api_bridge

  apache:
    image: ${IMAGE_NAME_APACHE}
    container_name: vuewithflask_apache
    restart: always
    ports:
      - '30443:30443'
      - '28443:443'
      - '27443:27443'
    volumes:
      - /media/markhsu/Data/DockerProtainer/vueWithFlask/etc/apache2:/etc/apache2
      - /media/markhsu/Data/DockerProtainer/vueWithFlask/etc/letsencrypt/live/markweb.idv.tw:/etc/letsencrypt/live/markweb.idv.tw

networks:
  api_bridge:
    driver: bridge

```

### 1.4.2. 部署流程關鍵腳本

#### 1.4.2.1. 撰寫docker自動化部署腳本

```bash
#!/bin/bash
#+-------------------------------------腳本說明--------------------------------------------+
# 自動化部署到HARBOR，並自動生成版號
# 使用方式: ./deploy_harbor.sh
#
# (C) 2023 - markhsu - licensed under markweb License v1.
#
#+----------------------------------------------------------------------------------------+

#+----------------------------------------------------------------------------------------+
#                                     接收參數
#+----------------------------------------------------------------------------------------+
# 提取参数
HARBOR_REGISTRY="$1"
HARBOR_USERNAME="$2"
HARBOR_PASSWORD="$3"
INITIAL_VERSION="$4"
image_name="$5"
dockerfile="$6"
HARBOR_PROJECT="$7"
#+----------------------------------------------------------------------------------------+
#                                     抓取版號
#+----------------------------------------------------------------------------------------+
#如果版號為空則給初始版號，否則就抓取git版號
version=$(git describe --tags --abbrev=0 | sed 's/^v//')
echo "Git版號是：$version"
if [ -z "$version" ]; then
    version="${INITIAL_VERSION}"
    echo "初始版號是：$version"
fi

#+----------------------------------------------------------------------------------------+
#                                     抓取commit message
#+----------------------------------------------------------------------------------------+
#抓取commit message來判斷要跳大版號、中版號、小版號
commit_message=$(git log --format=%B -n 2 | tail -n 1)
echo "提交訊息為：$commit_message"
#重大變更
if echo "$commit_message" | grep -q "BREAKING CHANGE"; then
    version_parts=$(echo $version | cut -d"." -f 1)
    echo "提交的重大更新版號是：$version_parts"
    major=$(($version_parts+1))
    echo "大版號是：$major"
    version="${major}.0.0"
    echo "串接版號是：$version"
#feat
elif echo "$commit_message" | grep -q "feat"; then
    version_parts=$(echo $version | cut -d"." -f 2)
    echo "取出的feat版號是：$version_parts"
    minor=$(($version_parts+1))
    echo "中版號是：$minor"
    version="${version_parts}.${minor}.0"
    echo "串接版號是：$version"
#fix
elif echo "$commit_message" | grep -q "fix"; then
    version_parts_major=$(echo $version | cut -d"." -f 1)
    version_parts_minor=$(echo $version | cut -d"." -f 2)
    version_parts_patch=$(echo $version | cut -d"." -f 3)
    echo "提交的fix大版號是：$version_parts_major"
    echo "提交的fix中版號是：$version_parts_minor"
    echo "提交的fix小版號是：$version_parts_patch"
    patch=$(($version_parts_patch+1))
    echo "小版號是：$patch"
    version="${version_parts_major}.${version_parts_minor}.${patch}"
    echo "串接版號是：$version"
#其他類型
else
    version_parts_major=$(echo $version | cut -d"." -f 1)
    version_parts_minor=$(echo $version | cut -d"." -f 2)
    version_parts_patch=$(echo $version | cut -d"." -f 3)
    echo "提交的fix大版號是：$version_parts_major"
    echo "提交的fix中版號是：$version_parts_minor"
    echo "提交的fix小版號是：$version_parts_patch"
    patch=$(($version_parts_patch+1))
    echo "小版號是：$patch"
    version="${version_parts_major}.${version_parts_minor}.${patch}"
    echo "串接版號是：$version"
fi

echo "提取的檔案名稱：$image_name"
echo "Dockerfile檔案名稱：$dockerfile"

#+----------------------------------------------------------------------------------------+
#                                     抓取git commit sha
#+----------------------------------------------------------------------------------------+
commit_sha=$(git rev-parse --short HEAD)
echo "git commit sha：$commit_sha"
version="v${version}-${commit_sha}"
echo "最終串接版號為：$version"

#+----------------------------------------------------------------------------------------+
#                                     部署到harbor
#+----------------------------------------------------------------------------------------+
echo "DEBUG: docker build -t ${HARBOR_REGISTRY}/${HARBOR_PROJECT}/my${image_name}:$version --label "commit_message=${commit_message}" --build-arg COMMIT_SHA=${commit_sha} -f $dockerfile"

# 新增.env文件
touch .env

echo "MYSQL_ROOT_PASSWORD=root" >> .env
echo "MYSQL_DATABASE=wordpress" >> .env
echo "MYSQL_USER=mark" >> .env
echo "MYSQL_PASSWORD=mark850409" >> .env

# 將image name寫入.env文件
# 根据 imagename 进行判断
if [ "$image_name" = "python" ]; then
    echo "IMAGE_NAME_PYTHON=${HARBOR_REGISTRY}/${HARBOR_PROJECT}/mypython:$version" >> .env
    echo "WordPress image added to .env"
elif [ "$image_name" = "apache" ]; then
    echo "IMAGE_NAME_APACHE=${HARBOR_REGISTRY}/${HARBOR_PROJECT}/myapache:$version" >> .env
    echo "Apache image added to .env"
elif [ "$image_name" = "vue" ]; then
    echo "IMAGE_NAME_VUE=${HARBOR_REGISTRY}/${HARBOR_PROJECT}/myvue:$version" >> .env
    echo "PhpMyAdmin image added to .env"
else
    echo "Unknown image name. Please provide valid image name: wordpress, apache, or phpmyadmin"
fi

docker build -t ${HARBOR_REGISTRY}/${HARBOR_PROJECT}/my${image_name}:$version --label "commit_message=${commit_message}" --build-arg COMMIT_SHA=${commit_sha} -f $dockerfile .
docker login -u ${HARBOR_USERNAME} -p ${HARBOR_PASSWORD} ${HARBOR_REGISTRY}
docker push ${HARBOR_REGISTRY}/${HARBOR_PROJECT}/my${image_name}:$version
```

#### 1.4.2.2. 撰寫Jenkins pipeline

```groovy
pipeline {
    agent any

    environment {
        GITLAB_CREDENTIALS = credentials('gitlab') // GitLab 認證
        SONARQUBE_CREDENTIALS = credentials('sonarqube') // SonarQube 認證
        SONARQUBE_URL = 'markweb.idv.tw:16443' // SonarQube 伺服器 URL
        SONAR_PROJECT_KEY = '20240727_SonarQube_flaskcrudvue' // SonarQube 專案金鑰
        SONAR_PROJECT_NAME = '20240727_SonarQube_flaskcrudvue' // SonarQube 專案名稱
        SOURCE_CODE_GIT_URL='ssh://git@markweb.idv.tw:2222/dockercomposeteam/flaskcrudvue_localhost.git' // GitLab URL
        PYTHON_ENV = "venv"  // 設定 Python 環境路徑
        HARBOR_REGISTRY="markweb.idv.tw:29443" // Harbor倉庫地址
        HARBOR_USERNAME="admin" // Harbor用户名
        HARBOR_PASSWORD="admin" // Harbor密碼
        HARBOR_PROJECT="myvuewithflaskrepo" // Harbor倉庫名稱
        INITIAL_VERSION="1.0.0" // git初始化版本號
        RSYNC_TARGET_FRONTEND_DIR = '/Backup/DockerProtainer/vueWithFlask/frontend'// 定義 rsync 目標目錄
        RSYNC_SOURCE_FRONTEND_DIR = '${WORKSPACE}/frontend' // 定義 rsync 源目錄（專案目錄）
        RSYNC_TARGET_BACKEND_DIR = '/Backup/DockerProtainer/vueWithFlask/backend'// 定義 rsync 目標目錄
        RSYNC_SOURCE_BACKEND_DIR = '${WORKSPACE}/backend' // 定義 rsync 源目錄（專案目錄）
    }

    stages {
        stage('從gitlab拉取專案') {
            steps {
                script {
                    // 從 GitLab 拉取專案
                    git url: SOURCE_CODE_GIT_URL, credentialsId: 'gitlab'
                }
            }
        }

        stage('SonarQube原始碼弱點掃描報告') {
            steps {
                script{
                    def version
                    try {
                        version = sh(script: "git describe --tags", returnStdout: true).trim()
                    } catch (Exception e) {
                        // 如果沒有標籤，使用預設版本號
                        version = "1.0.0"
                    }
                    withSonarQubeEnv('sonarqube') {
                    sh """
                    ${SONAR_SCANNER_HOME}sonar-scanner \
                    -Dsonar.projectKey=${SONAR_PROJECT_KEY} \
                    -Dsonar.projectVersion=${version} \
                    -Dsonar.sources=. \
                    -Dsonar.host.url=https://${SONARQUBE_URL} \
                    -Dsonar.login=$SONARQUBE_TOKEN
                    """
                }
                }

            }
        }


        stage('安裝套件') {
            steps {
                sh '''
                apt-get install python3-venv -y
                apt-get install -y zip
                '''
            }
        }


        stage('設定python環境變數') {
            steps {
                sh '''
                python3 -m venv $PYTHON_ENV
                source $PYTHON_ENV/bin/activate
                pip install -r requirements.txt
                pip install pyinstaller  # 安裝 pyinstaller
                '''
            }
        }

        stage('建置ALLURE單元測試環境') {
            steps {
                sh '''
                # 建立虛擬環境
                source $PYTHON_ENV/bin/activate

                # 確保所有依賴項都已安裝
                pip install -r ${WORKSPACE}/requirements.txt

                # 運行 pytest
                pytest -s -q ${WORKSPACE}/test_math_operations.py --alluredir=${WORKSPACE}/allure-results --clean-alluredir
                '''
            }
        }

        stage('產生ALLURE單元測試報告') {
            steps {
                sh '''
                # 啟動虛擬環境
                source $PYTHON_ENV/bin/activate

                # 確保 ${ALLURE_HOME} 變數設置正確
                echo "ALLURE_HOME is set to $ALLURE_HOME"

                # 刪除舊報告目錄（如果存在）
                rm -rf ${WORKSPACE}/allure-report

                # 生成新的 Allure 報告
                ${ALLURE_HOME}allure generate ${WORKSPACE}/allure-results -o ${WORKSPACE}/allure-report
                '''
            }
        }

        stage('打包allure-report') {
            steps {
                // 將打包結果存放到Jenkins工作目錄下的allure-report
                 allure([
                    includeProperties: false,
                    jdk: '',
                    results: [[path: '${WORKSPACE}/allure-report']]
                ])
            }
        }

        stage('打包Python腳本') {
            steps {
                sh '''
                # 啟動虛擬環境
                source $PYTHON_ENV/bin/activate

                # 打包需要的python檔案
                pyinstaller --onefile backend/app.py

                # 印出打包目錄，確認檔案是否存在
                ls -l dist

                # 重命名打包結果
                mv dist/app dist/app.exe
                '''
            }
        }
         stage('部署腳本') {
            steps {
               script {
                    def dockerfiles = sh(script: 'find dockerfiles -mindepth 2 -maxdepth 2 -type f -name "Dockerfile_*"', returnStdout: true).trim().split('\n')
                    echo "dockerfiles: ${dockerfiles}"
                    for (def dockerfile in dockerfiles) {
                        def imageName = dockerfile.tokenize('_')[-1].tokenize('/')[0]
                        echo "Image Name: ${imageName}"
                        echo "Dockerfile: ${dockerfile}"
                        sh "sh deploy_harbor.sh ${HARBOR_REGISTRY} ${HARBOR_USERNAME} ${HARBOR_PASSWORD} ${INITIAL_VERSION} ${imageName} ${dockerfile} ${HARBOR_PROJECT}"
                    }
                }

            }
        }

        stage('停止並移除容器') {
            steps {
                script {
                    def containers = ['vuewithflask_apache', 'vuewithflask_backend', 'vuewithflask_db','vuewithflask_frontend','vuewithflask_phpmyadmin']
                    for (container in containers) {
                        def containerId = sh(returnStdout: true, script: "docker ps -aq --filter name=$container").trim()
                        if (containerId) {
                            sh "docker stop $containerId"
                            sh "docker rm $containerId"
                        } else {
                            echo "容器 $container 不存在,跳過移除"
                        }
                    }
                }
            }
        }

        stage('啟動容器') {
            steps {
                script {
                     sh 'docker-compose up -d --build'
                }
            }
        }

        stage('使用 rsync 同步專案到目標目錄') {
            steps {
                script {
                    // 使用 rsync 同步專案到目標目錄
                    sh "rsync -avz ${RSYNC_SOURCE_FRONTEND_DIR}/ ${RSYNC_TARGET_FRONTEND_DIR}/"
                    sh "rsync -avz ${RSYNC_SOURCE_BACKEND_DIR}/ ${RSYNC_TARGET_BACKEND_DIR}/"
                }
            }
        }

    }

    post {
        always {
            script {
                def buildResult = currentBuild.currentResult
                // 執行LINE NOTIFY腳本
                sh """
                echo "部署结果: ${buildResult}"
                sh ${WORKSPACE}/send_line_notify.sh $JOB_NAME $BUILD_NUMBER $BUILD_URL $GIT_BRANCH $GIT_COMMIT $WORKSPACE $LINE_NOTIFY_TOKEN ${buildResult}
                """
                // 讀取HTML模板內容
                def customHtmlTemplate = readFile('custom.html')
                // 寄送郵件
                emailext (
                    subject: "$JOB_NAME-#$BUILD_NUMBER-${buildResult}",
                    body: customHtmlTemplate,
                    mimeType: 'text/html',
                    to: "markhsu0704@gmail.com"
                )
            }
            script {
                // 新增單元測試報告結果的存檔
                archiveArtifacts artifacts: 'allure-results/**', allowEmptyArchive: true
                // 新增python打包結果的存檔
                archiveArtifacts artifacts: 'dist/**', allowEmptyArchive: true
            }
             // 安装 curl & pandoc
            script {
                sh '''
                if ! command -v curl &> /dev/null; then sudo apt update && sudo apt install -y curl; fi
                if ! command -v pandoc &> /dev/null; then apt update && apt install -y pandoc; fi
                '''
            }
            script {
                // 移除 markdown 文件中的標題標記
                // 使用 pandoc 將markdown轉換為HTML
                sh '''
                sed -i 's/### //' CHANGELOG.md
                sed -i 's/## //' CHANGELOG.md
                pandoc -f markdown -t html -o changelog.html CHANGELOG.md
                '''

                // 讀取自定義CSS樣式
                def cssContent = readFile('style.css')

                // 讀取生成的 HTML 文件
                def changelogHtml = readFile('changelog.html')


                // 在 HTML 文件的開頭放入居中的 H1 標題
                changelogHtml = "<style>${cssContent}</style><h1>$JOB_NAME-#$BUILD_NUMBER-Git版本變更紀錄</h1>\n" + changelogHtml

                changelogHtml = "<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\">" + changelogHtml


                // 將變更日誌保存到文件
                writeFile file: 'changelog.html', text: changelogHtml


                // 歸檔HTML
                archiveArtifacts artifacts: 'changelog.html', onlyIfSuccessful: false

                // 在 Jenkins 增加HTML連接
                publishHTML(target: [
                    allowMissing: false,
                    alwaysLinkToLastBuild: false,
                    keepAll: true,
                    reportDir: '.',
                    reportFiles: 'changelog.html',
                    reportName: 'Gitlab版本變更紀錄'
                ])
            }


        }
    }

}
```

#### 1.4.2.3. 撰寫單元測試所需腳本

> [!note] 小提示 
> 這裡的單元測試只是測試，實際需求不會那麼簡單
>1. 實際會做資料庫連線單元測試
>2. 其他可能需要的測試(暫時想不到)


```python
def add(a, b):
    return a + b
```


```python
from math_operations import add

def test_add():
    assert add(1, 2) == 3
    assert add(-1, 1) == 0
    assert add(-1, -1) == -2
```


### 1.4.3. 部署後流程所需腳本

#### 1.4.3.1. 撰寫LINE NOTIFY部署後通知腳本


```bash
#!/bin/bash
#+-------------------------------------腳本說明--------------------------------------------+
# MARKWEB_SERVER部署結果訊息傳送
# 使用方式: ./send_line_notify.sh
#
# (C) 2023 - markhsu - licensed under markweb License v1.
#
#+----------------------------------------------------------------------------------------+

#+----------------------------------------------------------------------------------------+
#                                     增加LINE NOTIFY通知
#+----------------------------------------------------------------------------------------+
apt update && apt install curl -y

# 從Jenkins參數取得訊息

MESSAGE="項目名稱:$1
部署版號:$2
部署日誌:$3
部署結果:$8
部署分支:$4
提交識別碼:$5
工作目錄:$6
"

# DEBUG 訊息
echo "項目名稱:$1"
echo "部署版號:$2"
echo "部署日誌:$3"
echo "部署結果:$8"
echo "部署分支:$4"
echo "提交識別碼:$5"
echo "工作目錄:$6"

# 呼叫Line notify API
curl -X POST -H "Authorization: Bearer $7" \
    -F "message=$MESSAGE" \
    https://notify-api.line.me/api/notify
```

#### 1.4.3.2. 撰寫郵件通知模板

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>${ENV, var="JOB_NAME"}-第${BUILD_NUMBER}次佈署日誌</title>
<style>
.post_body{
    border-bottom: 2px dashed #ccc;
    border: 2px dashed #202124;
    padding: 15px;
    margin-bottom: 20px;
    border-left: 3px solid #202124;
}
textarea{
border: 2px dashed #202124;
}
</style>
</head>
<body leftmargin="8" marginwidth="0" topmargin="8" marginheight="4"
    offset="0">
    <table width="95%" cellpadding="0" cellspacing="0"
        style="font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif">
        <tr>
            <td>
                <h2>
                    <font>以下来自MarkWeb.Jenkins的郵件通知</font>
                </h2>
            </td>
        </tr>
        <tr>
            <td class='post_body'>
                <b><font color="#0B610B">佈署訊息</font></b>
             </td>
        </tr>
        <tr>
            <td>
                <ul>
                    <li>項目名稱&nbsp;：&nbsp;${PROJECT_NAME}</li>
                    <li>佈署版號&nbsp;：&nbsp;${BUILD_NUMBER}</li>
                    <li>佈署結果&nbsp;：&nbsp;${BUILD_STATUS}</li>
                    <li>佈署日誌&nbsp;：&nbsp;<a href="${BUILD_URL}console">${BUILD_URL}console</a></li>
                    <li>觸發原因&nbsp;：${CAUSE}</li>
                    <li>單元測試報告&nbsp;：<a href="${BUILD_URL}testReport/">${BUILD_URL}testReport/</a></li>
                    <li>工作目錄&nbsp;：&nbsp;<a href="${PROJECT_URL}ws">${PROJECT_URL}lastSuccessfulBuild/artifact/</a></li>
                </ul>
            </td>
        </tr>
        <tr>
            <td class='post_body'><b><font color="#0B610B">佈署日誌:</font></b>
        </tr>
        <br />
        <br />
        <tr>
            <td>
            <textarea cols="120" rows="30" readonly="readonly" style="font-family: Courier New">${BUILD_LOG}</textarea>
            </td>
        </tr>
    </table>
</body>
</html>
```

## 1.5. 問題處理

> [!warning] 小提示 
> 1.  ALLURE環境變數找不到的問題?
> (a) 請檢查Jenkins的ALLURE_HOME環境變數是否設定正確
> (b) 點擊Allure Commandline，輸入名稱以及安裝目錄(這裡不要設定到bin)
> 2. 下載連結請參考這裡
> https://github.com/allure-framework/allure2
> 3. 目前Allure的新版本已不支援產生XML，所以在Jenkins的pipeline不要加上junit參數(這參數只支援產生XML，但新版本單元測試紀錄都是json格式)

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/7f17b43d-202407271937035.png)

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/8930d02c-202407271938026.png)


## 1.6. 完成畫面

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/7Rj2fb771e1-202407272001631.png)

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/9778c577-202407271929278.png)

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/LyDc1172715-202407271930465.png)

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/eez07daa084-202407271930714.png)

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/Lf3819489fc-202407271930757.png)

![](https://mybookstack.zeabur.app/uploads/images/gallery/2025-08/YH52a11aef0-202407271932444.png)
